<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robust Pipeline OCR (B) — Kannada + English → Translation</title>

<!-- Tesseract.js (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
  :root{ --bg:#071021; --card:#0f1720; --muted:#9fb0c8; --accent1:#ff6b81; --accent2:#8a2be2; --text:#e6eef7; }
  body{ margin:0; font-family:Inter,Arial,Helvetica,sans-serif; background:linear-gradient(180deg,#03040a,#071021); color:var(--text); }
  .wrap{max-width:980px;margin:16px auto;padding:16px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  h1{margin:0;font-size:20px}
  .lead{color:var(--muted);font-size:13px;margin-top:6px}
  .grid{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
  .col{flex:1;min-width:280px}
  .card{padding:12px;border-radius:10px;background:var(--card);border:1px solid rgba(255,255,255,0.02)}
  input[type=file]{width:100%}
  .preview{width:100%;max-height:320px;object-fit:contain;border-radius:8px;background:#fff;margin-top:8px;display:none}
  .box{width:100%;min-height:120px;border-radius:8px;padding:10px;background:#071018;color:var(--text);font-family:monospace;white-space:pre-wrap;overflow:auto}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{padding:10px 12px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:white;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
  .small{font-size:13px;color:var(--muted)}
  .log{max-height:240px;overflow:auto;padding:10px;background:rgba(0,0,0,0.25);border-radius:8px;font-family:monospace;font-size:13px}
  .credits{font-family:Pacifico,cursive;text-align:right;margin-top:10px;color:rgba(255,255,255,0.9)}
  @media(max-width:820px){ .grid{flex-direction:column} .col{min-width:unset} }
</style>
</head>
<body>
  <div class="wrap">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h1>Pipeline OCR (B) — Kannada + English → English Translation</h1>
        <div class="lead">Preprocessing + rotations + separate Kannada/English OCR → chunked translation with fallbacks</div>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="col card">
        <div class="small">Upload image (photo / screenshot). Processing starts automatically.</div>
        <input id="fileInput" type="file" accept="image/*" style="margin-top:8px"/>
        <div style="margin-top:10px" class="controls">
          <button id="processNow" class="secondary">Process Now</button>
          <button id="retryBtn" class="secondary">Retry last</button>
        </div>

        <img id="preview" class="preview" alt="preview"/>

        <div style="margin-top:10px" class="small">Pipeline Log</div>
        <div id="log" class="log">Idle. Upload an image to start.</div>
      </div>

      <div class="col card">
        <div class="small">OCR Combined Output (Kannada first + English)</div>
        <div id="ocrBox" class="box">(OCR will appear here)</div>
        <div class="controls">
          <button id="downloadOcr" class="secondary">Download OCR</button>
          <button id="copyOcr" class="secondary">Copy OCR</button>
        </div>

        <div style="margin-top:12px" class="small">English Translation (chunked & fallback)</div>
        <div id="transBox" class="box">(Translation will appear here)</div>
        <div class="controls" style="margin-top:8px">
          <button id="downloadTrans" class="secondary">Download Translation</button>
          <button id="retryTrans" class="secondary">Retry Translation</button>
        </div>

        <div class="credits">Created by Animesh</div>
      </div>
    </div>
  </div>

<script>
/* ================= CONFIG ================= */
const ROTATIONS = [-2,0,2];        // degrees to try for small skew
const MAX_DIM = 1400;              // max resize to speed up
const CHUNK_SIZE = 400;            // translation chunk size (~safe <500)
const OCR_TIMEOUT = 20000;         // ms per recognition attempt
const TRANSLATION_TIMEOUT = 9000;  // ms per translator request

const TRANSLATORS = [
  { name:'MyMemory', type:'get', build: t => `https://api.mymemory.translated.net/get?q=${encodeURIComponent(t)}&langpair=kn|en` },
  { name:'libretranslate.de', type:'post', url:'https://libretranslate.de/translate' },
  { name:'argosopentech', type:'post', url:'https://translate.argosopentech.com/translate' },
  { name:'astian', type:'post', url:'https://translate.astian.org/translate' }
];

/* ================= DOM ================= */
const fileInput = document.getElementById('fileInput');
const processNow = document.getElementById('processNow');
const retryBtn = document.getElementById('retryBtn');
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const ocrBox = document.getElementById('ocrBox');
const transBox = document.getElementById('transBox');
const downloadOcr = document.getElementById('downloadOcr');
const copyOcr = document.getElementById('copyOcr');
const downloadTrans = document.getElementById('downloadTrans');
const retryTrans = document.getElementById('retryTrans');

let lastFile = null;
let lastCombinedText = '';
let lastTranslation = '';

/* ================= Helpers ================= */
function log(msg){
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `${ts} — ${msg}\n` + logEl.textContent;
  console.log(msg);
}
function showOcr(t){ ocrBox.textContent = t || '(no OCR)'; }
function showTrans(t){ transBox.textContent = t || '(no translation)'; }
function downloadText(filename, text){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([text||''],{type:'text/plain'})); a.download=filename; a.click(); }
function copyText(t){ navigator.clipboard?.writeText(t).then(()=>alert('Copied'), ()=>alert('Copy failed')); }

/* ================= Preprocessing Utilities ================= */
function resizeCanvas(img, maxDim=MAX_DIM){
  const scale=Math.min(1, maxDim/Math.max(img.width,img.height));
  const c=document.createElement('canvas'); c.width=Math.round(img.width*scale); c.height=Math.round(img.height*scale);
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,c.width,c.height); return c;
}

function contrastStretch(c){
  try {
    const ctx=c.getContext('2d'); const id=ctx.getImageData(0,0,c.width,c.height); const d=id.data;
    let min=255,max=0;
    for(let i=0;i<d.length;i+=4){ const lum=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; if(lum<min)min=lum; if(lum>max)max=lum; }
    const range=Math.max(1,max-min);
    for(let i=0;i<d.length;i+=4){ const lum=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; const v=Math.round((lum-min)*255/range); d[i]=d[i+1]=d[i+2]=v; }
    ctx.putImageData(id,0,0);
  } catch(e){ log('contrast error: '+e.message); }
  return c;
}

function sharpen(c){
  try {
    const ctx=c.getContext('2d');
    const clone=document.createElement('canvas'); clone.width=c.width; clone.height=c.height;
    const cctx=clone.getContext('2d');
    if(cctx.filter!==undefined){
      cctx.filter='blur(1px)'; cctx.drawImage(c,0,0);
      const idb=cctx.getImageData(0,0,c.width,c.height); const id=ctx.getImageData(0,0,c.width,c.height);
      const db=idb.data, da=id.data;
      for(let i=0;i<da.length;i+=4){ let v=da[i]+0.6*(da[i]-db[i]); v=Math.max(0,Math.min(255,Math.round(v))); da[i]=da[i+1]=da[i+2]=v; }
      ctx.putImageData(id,0,0);
    } else { contrastStretch(c); }
  } catch(e){ log('sharpen error: '+e.message); }
  return c;
}

// Sauvola-like adaptive threshold (heavy, but useful)
function sauvola(c){
  try {
    const ctx=c.getContext('2d'); const w=c.width,h=c.height; const id=ctx.getImageData(0,0,w,h), d=id.data;
    const I=new Uint8ClampedArray(w*h); for(let i=0,j=0;i<d.length;i+=4,j++){ I[j]=Math.round(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]); }
    const ws=15, half=Math.floor(ws/2);
    const out=new Uint8ClampedArray(w*h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let sum=0,sum2=0,cnt=0;
        for(let yy=Math.max(0,y-half);yy<=Math.min(h-1,y+half);yy++){
          for(let xx=Math.max(0,x-half);xx<=Math.min(w-1,x+half);xx++){
            const v=I[yy*w+xx]; sum+=v; sum2+=v*v; cnt++;
          }
        }
        const mean=sum/cnt; const varr=(sum2/cnt)-(mean*mean); const std=Math.sqrt(Math.max(0,varr));
        const R=128, k=0.34;
        const thresh = mean*(1 + k*((std/R)-1));
        out[y*w+x] = I[y*w+x] > thresh ? 255 : 0;
      }
    }
    for(let j=0,idx=0;j<d.length;j+=4,idx++){ const v=out[idx]; d[j]=d[j+1]=d[j+2]=v; }
    ctx.putImageData(id,0,0);
  } catch(e){ log('sauvola error: '+e.message); }
  return c;
}

function rotateCanvas(src, deg){
  const r=deg*Math.PI/180; const w=src.width,h=src.height;
  const sin=Math.abs(Math.sin(r)), cos=Math.abs(Math.cos(r));
  const nw=Math.ceil(w*cos + h*sin), nh=Math.ceil(w*sin + h*cos);
  const c=document.createElement('canvas'); c.width=nw; c.height=nh;
  const ctx=c.getContext('2d'); ctx.fillStyle='white'; ctx.fillRect(0,0,nw,nh);
  ctx.translate(nw/2,nh/2); ctx.rotate(r); ctx.drawImage(src, -w/2, -h/2);
  return c;
}

function canvasToDataUrl(c){ return c.toDataURL('image/png'); }

/* ================= Simple safe recognize wrapper (uses Tesseract.recognize) ================= */
function recognizeWithTimeout(dataUrl, lang, timeout=OCR_TIMEOUT){
  return new Promise(async (resolve, reject) => {
    let timed=false;
    const timer=setTimeout(()=>{ timed=true; reject(new Error('OCR timeout')); }, timeout);
    try {
      const res = await Tesseract.recognize(dataUrl, lang, { logger: m => {/*silent*/} });
      if (!timed){ clearTimeout(timer); resolve(res.data); }
    } catch(err){
      if (!timed){ clearTimeout(timer); reject(err); }
    }
  });
}

/* ================= MAIN PIPELINE ================= */
fileInput.addEventListener('change', e => {
  const f = e.target.files && e.target.files[0];
  if (f){ lastFile = f; preview.src = URL.createObjectURL(f); preview.style.display='block'; runPipeline(f); }
});
processNow.addEventListener('click', ()=>{ if (fileInput.files[0]) runPipeline(fileInput.files[0]); else alert('Choose an image'); });
retryBtn.addEventListener('click', ()=>{ if (lastFile) runPipeline(lastFile); else alert('No last file'); });
retryTrans.addEventListener('click', ()=>{ if (lastCombinedText) doTranslationChunks(lastCombinedText); else alert('No OCR text'); });
downloadOcr.addEventListener('click', ()=> downloadText('ocr.txt', lastCombinedText));
copyOcr.addEventListener('click', ()=> copyText(lastCombinedText));
downloadTrans.addEventListener('click', ()=> downloadText('translation.txt', lastTranslation));

async function runPipeline(file){
  try {
    log('Starting pipeline for file: ' + file.name);
    showOcr('(processing...)'); showTrans('(waiting...)');
    const img = new Image(); img.src = URL.createObjectURL(file); await img.decode();

    const base = resizeCanvas(img, MAX_DIM);

    // build preprocessing variants
    const variants = [];
    // plain
    const plain = document.createElement('canvas'); plain.width=base.width; plain.height=base.height; plain.getContext('2d').drawImage(base,0,0);
    variants.push({name:'plain', canvas:plain});
    // contrast + sharpen
    const cs = document.createElement('canvas'); cs.width=base.width; cs.height=base.height; cs.getContext('2d').drawImage(base,0,0);
    contrastStretch(cs); sharpen(cs); variants.push({name:'contrast_sharp', canvas:cs});
    // contrast + sauvola
    const sa = document.createElement('canvas'); sa.width=base.width; sa.height=base.height; sa.getContext('2d').drawImage(base,0,0);
    contrastStretch(sa); sauvola(sa); variants.push({name:'contrast_sauvola', canvas:sa});

    // Try Kannada OCR across variants and rotations
    let bestKan = {score:-1, text:'', details:null};
    for (const rot of ROTATIONS){
      for (const v of variants){
        const canvas = (rot===0) ? v.canvas : rotateCanvas(v.canvas, rot);
        const url = canvasToDataUrl(canvas);
        log(`KAN try: variant=${v.name}, rot=${rot}°`);
        try {
          const data = await recognizeWithTimeout(url, 'kan');
          const text = (data && data.text) ? data.text.trim() : '';
          const kcount = (text.match(/[\u0C80-\u0CFF]/g) || []).length;
          const score = kcount*3 + text.replace(/\s+/g,'').length;
          log(`KAN result len=${text.length}, kannada=${kcount}, score=${score}`);
          if (score > bestKan.score){ bestKan = {score, text, details:{variant:v.name, rot}}; showOcr(bestKan.text); }
          if (kcount >= 20){ log('KAN early accept'); rot=999; break; }
        } catch(err){
          log(`KAN failed variant=${v.name}, rot=${rot}: ${err.message}`);
        }
      }
    }

    // English OCR (use plain+small rotations)
    let bestEng = {score:-1, text:'', details:null};
    for (const rot of ROTATIONS){
      const canvas = (rot===0) ? plain : rotateCanvas(plain, rot);
      const url = canvasToDataUrl(canvas);
      log(`ENG try: rot=${rot}°`);
      try {
        const data = await recognizeWithTimeout(url, 'eng');
        const text = (data && data.text) ? data.text.trim() : '';
        const score = text.replace(/\s+/g,'').length;
        log(`ENG result len=${text.length}, score=${score}`);
        if (score > bestEng.score){ bestEng = {score, text, details:{rot}}; }
        if (score > 30) break;
      } catch(err){
        log(`ENG failed rot=${rot}: ${err.message}`);
      }
    }

    const kanText = bestKan.text || '';
    const engText = bestEng.text || '';
    const combined = (kanText + "\n" + engText).trim();
    lastCombinedText = combined;
    showOcr(combined || '(no OCR result)');
    log(`Selected KAN variant=${bestKan.details?.variant||'n/a'} rot=${bestKan.details?.rot||0} score=${bestKan.score}`);
    log(`Selected ENG rot=${bestEng.details?.rot||0} score=${bestEng.score}`);

    const kcountTotal = (combined.match(/[\u0C80-\u0CFF]/g) || []).length;
    if (kcountTotal < 4 && combined.length < 10){
      log('No useful Kannada or English found. Try a better photo (closer, flatter, brighter).');
      showTrans('No translation: no useful OCR text.');
      return;
    }

    // proceed to translation (chunked)
    await doTranslationChunks(combined);

  } catch(err){
    log('Pipeline error: ' + (err && err.message || String(err)));
    showOcr('(pipeline error)');
    showTrans('(pipeline error)');
  }
}

/* ================= TRANSLATION: chunking & fallback ================= */
function chunkText(text, maxLen=CHUNK_SIZE){
  const paragraphs = text.split(/\n{2,}/g);
  const chunks = [];
  for (const p of paragraphs){
    if (!p.trim()) continue;
    let remaining = p.trim();
    while (remaining.length > 0){
      if (remaining.length <= maxLen){ chunks.push(remaining); break; }
      // split at last punctuation / newline or whitespace
      const sub = remaining.slice(0, maxLen);
      let splitPos = Math.max(sub.lastIndexOf('.'), sub.lastIndexOf('।'), sub.lastIndexOf('?'), sub.lastIndexOf('!'), sub.lastIndexOf('\n'));
      if (splitPos > Math.floor(maxLen*0.6)) {
        chunks.push(remaining.slice(0, splitPos+1).trim());
        remaining = remaining.slice(splitPos+1).trim();
      } else {
        const sp = sub.lastIndexOf(' ');
        const cut = (sp > 50) ? sp : maxLen;
        chunks.push(remaining.slice(0, cut).trim());
        remaining = remaining.slice(cut).trim();
      }
    }
  }
  if (chunks.length === 0 && text.trim()) chunks.push(text.trim().slice(0, maxLen));
  return chunks;
}

async function translateChunkWithEp(chunk, ep){
  try {
    if (ep.type === 'get'){
      const url = ep.build(chunk);
      const res = await fetchWithTimeout(url, {}, TRANSLATION_TIMEOUT);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const j = await res.json();
      const t = j.responseData && j.responseData.translatedText;
      if (t && t.trim()) return {ok:true, text:t, source:ep.name};
      return {ok:false};
    } else {
      const res = await fetchWithTimeout(ep.url, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ q: chunk, source:'kn', target:'en', format:'text' })
      }, TRANSLATION_TIMEOUT);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const j = await res.json();
      const t = j.translatedText || j.translation || j.result || (j[0] && j[0].map? j[0].map(x=>x[0]).join('') : null);
      if (t && t.trim()) return {ok:true, text:t, source:ep.name};
      return {ok:false};
    }
  } catch(e){
    log(`${ep.name} failed: ${e.message}`);
    return {ok:false};
  }
}

async function doTranslationChunks(fullText){
  try {
    showTrans('Translating…'); log('Preparing chunks for translation...');
    const chunks = chunkText(fullText, CHUNK_SIZE);
    log(`Chunks: ${chunks.length}`);
    const results = [];
    for (let i=0;i<chunks.length;i++){
      const chunk = chunks[i];
      log(`Translating chunk ${i+1}/${chunks.length} (len=${chunk.length})`);
      let translated = null;
      for (const ep of TRANSLATORS){
        const res = await translateChunkWithEp(chunk, ep);
        if (res.ok){ translated = res.text; log(`Chunk ${i+1} translated by ${res.source}`); break; }
      }
      if (!translated){
        translated = '[Translation unavailable for this chunk]';
        log(`Chunk ${i+1} failed on all endpoints.`);
      }
      results.push(translated);
      // polite delay
      await new Promise(r=>setTimeout(r, 200));
    }
    const final = results.join('\n\n');
    lastTranslation = final;
    showTrans(final);
    log('Translation complete.');
  } catch(e){
    log('Translation pipeline error: '+(e && e.message));
    showTrans('Translation failed.');
  }
}

function fetchWithTimeout(url, opts={}, ms=8000){
  return new Promise((resolve,reject)=>{
    const timer=setTimeout(()=>reject(new Error('timeout')), ms);
    fetch(url, opts).then(res=>{ clearTimeout(timer); resolve(res); }).catch(err=>{ clearTimeout(timer); reject(err); });
  });
}

/* ================= initial log ================= */
log('Ready. Upload an image (Kannada + English). Processing starts automatically.');

</script>
</body>
</html>
