<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robust Kannada OCR (online-first, fallback to Tesseract)</title>

<!-- Tesseract -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

<style>
:root{--bg:#070812;--card:#0f1720;--muted:#9fb0c8;--accent:#ff6b81;--txt:#e6eef7}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,var(--bg),#071021);color:var(--txt);font-family:Inter,Arial,sans-serif}
.container{max-width:960px;margin:12px auto;padding:12px}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
.logo{width:54px;height:54px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#8a2be2);display:flex;align-items:center;justify-content:center;font-weight:700}
.lead{color:var(--muted);font-size:13px;margin-top:6px}

/* layout */
.main{display:flex;gap:16px;flex-wrap:wrap;margin-top:14px}
.left{flex:0 0 130px}
.right{flex:1;min-width:280px}

/* drop box 1" */
#dropBox{width:96px;height:96px;border-radius:10px;border:2px dashed rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;cursor:pointer;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
.hint{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}

.card{padding:12px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
.preview{width:100%;border-radius:10px;display:block}

/* output */
#log{white-space:pre-wrap;color:var(--muted);font-size:13px;max-height:260px;overflow:auto;padding:8px;border-radius:8px;background:rgba(0,0,0,0.25)}
#ocrText, #translitText, #transText{width:100%;min-height:120px;border-radius:8px;padding:10px;background:rgba(0,0,0,0.35);border:1px solid rgba(255,255,255,0.03);color:var(--txt);font-size:14px;resize:vertical;display:none}
.progress{height:10px;background:#232630;border-radius:6px;overflow:hidden;margin-top:10px}
.bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#8a2be2)}

.small{font-size:13px;color:var(--muted)}

@media(max-width:820px){.main{flex-direction:column}.left{order:2}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div style="display:flex;gap:12px;align-items:center">
      <div class="logo">KN→EN</div>
      <div>
        <div style="font-weight:700">Kannada OCR — Robust</div>
        <div class="lead">Online-first OCR.space → fallback Tesseract (client). Auto process on upload.</div>
      </div>
    </div>
    <div class="small">No user key required (demo). Add OCR.space key in UI if needed.</div>
  </div>

  <div class="main">
    <div class="left">
      <div class="card" style="text-align:center">
        <div id="dropBox" title="Click or drop image">Drop / Click</div>
        <div class="hint">Drag or click (≈1" × 1")</div>
        <input id="fileInput" type="file" accept="image/*" style="display:none">
        <img id="previewImg" class="preview" style="display:none;margin-top:10px"/>
        <div style="margin-top:8px" class="small">Processing starts automatically.</div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="small">Settings</div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-direction:column">
          <input id="ocrKey" placeholder="OCR.space API key (optional)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--txt)"/>
          <select id="translateEndpoint" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--txt)">
            <option value="https://translate.argosopentech.com/translate">LibreTranslate (argos)</option>
            <option value="none">No translation</option>
          </select>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Pipeline Log</div>
        </div>
        <div id="log" style="margin-top:8px">Idle. Drop an image to start.</div>
        <div class="progress"><div id="bar" class="bar"></div></div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="small">OCR Extracted (Kannada / Mixed)</div>
        <textarea id="ocrText" readonly></textarea>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="small">Transliteration (Latin)</div>
        <textarea id="translitText" readonly></textarea>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="small">Translation (English meaning)</div>
        <textarea id="transText" readonly></textarea>
      </div>

      <div style="margin-top:12px;display:flex;justify-content:flex-end">
        <div style="font-family:Pacifico,cursive;color:rgba(255,255,255,0.9);">Created by Animesh</div>
      </div>
    </div>
  </div>
</div>

<script>
/* Robust online-first OCR pipeline with Tesseract fallback and timeouts.
   - Try OCR.space (online). If success → parse -> transliterate -> translate.
   - If OCR.space fails or returns no useful text, run Tesseract (client).
   - Preprocess: resize to max 1000px, grayscale, contrast, mild blur, unsharp mask.
   - Tesseract recognize timeout fallback: 45s.
*/

const dropBox = document.getElementById('dropBox');
const fileInput = document.getElementById('fileInput');
const previewImg = document.getElementById('previewImg');
const logEl = document.getElementById('log');
const bar = document.getElementById('bar');

const ocrKeyEl = document.getElementById('ocrKey');
const translateEndpointEl = document.getElementById('translateEndpoint');

const ocrTextEl = document.getElementById('ocrText');
const translitEl = document.getElementById('translitText');
const transEl = document.getElementById('transText');

dropBox.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if (f) startPipeline(f);
  fileInput.value = '';
});
['dragenter','dragover'].forEach(ev => dropBox.addEventListener(ev, e=>{ e.preventDefault(); dropBox.style.borderColor='rgba(255,107,129,0.6)'; }));
['dragleave'].forEach(ev => dropBox.addEventListener(ev, e=>{ e.preventDefault(); dropBox.style.borderColor='rgba(255,255,255,0.06)'; }));
dropBox.addEventListener('drop', e=>{
  e.preventDefault();
  dropBox.style.borderColor='rgba(255,255,255,0.06)';
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if (f) startPipeline(f);
});

/* logging */
function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.textContent = `${time} — ${msg}\n` + logEl.textContent;
  console.log(msg);
}
function setProgress(p){
  bar.style.width = Math.max(0,Math.min(100,p)) + '%';
}

/* simple check for useful text */
function isUsefulText(t){
  if (!t) return false;
  const s = (''+t).replace(/\s+/g,'').replace(/[0-9\W_]+/g,'');
  return s.length >= 3;
}

/* image preprocessing: resize, grayscale, contrast, mild blur, unsharp */
async function preprocessImage(img, maxSize=1000){
  const scale = Math.min(1, maxSize / Math.max(img.width, img.height));
  const w = Math.max(200, Math.round(img.width * scale));
  const h = Math.max(200, Math.round(img.height * scale));
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  ctx.drawImage(img, 0, 0, w, h);

  // get pixels
  let id = ctx.getImageData(0,0,w,h);
  let d = id.data;

  // grayscale + contrast stretch
  let min=255, max=0;
  for (let i=0;i<d.length;i+=4){
    const lum = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    if (lum < min) min = lum;
    if (lum > max) max = lum;
  }
  const range = Math.max(1, max - min);
  for (let i=0;i<d.length;i+=4){
    let lum = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    // stretch contrast
    let v = Math.round((lum - min) * 255 / range);
    // slight brighten
    v = Math.min(255, Math.round(v * 1.05 + 3));
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(id,0,0);

  // mild blur (box blur) to reduce speckles
  const tmp = ctx.getImageData(0,0,w,h);
  const td = tmp.data;
  const radius = 1; // small
  for (let y=1;y<h-1;y++){
    for (let x=1;x<w-1;x++){
      let sum=0;
      for (let yy=-radius;yy<=radius;yy++){
        for (let xx=-radius;xx<=radius;xx++){
          const idx = ((y+yy)*w + (x+xx)) * 4;
          sum += td[idx];
        }
      }
      const avg = Math.round(sum / ((radius*2+1)*(radius*2+1)));
      const idxc = (y*w + x)*4;
      d[idxc]=d[idxc+1]=d[idxc+2]=avg;
    }
  }
  ctx.putImageData(id,0,0);

  // unsharp mask (basic): original - blurred -> add
  // create blurred canvas quickly using ctx.filter if supported
  try {
    const clone = document.createElement('canvas');
    clone.width = w; clone.height = h;
    const cctx = clone.getContext('2d');
    cctx.filter = 'blur(1px)';
    cctx.drawImage(c,0,0);
    const blurId = cctx.getImageData(0,0,w,h).data;
    const base = ctx.getImageData(0,0,w,h);
    for (let i=0;i<base.data.length;i+=4){
      const sharpen = base.data[i] + (base.data[i] - blurId[i]) * 0.6;
      const v = Math.max(0,Math.min(255, Math.round(sharpen)));
      base.data[i]=base.data[i+1]=base.data[i+2]=v;
    }
    ctx.putImageData(base,0,0);
  } catch(e){
    // ignore if filter unsupported
  }

  return c.toDataURL('image/png');
}

/* OCR.space online recognition (base64 dataURL) */
async function ocrSpaceRecognize(dataUrl, apiKey){
  const key = (apiKey && apiKey.trim()) ? apiKey.trim() : 'helloworld';
  const base64 = dataUrl.split(',')[1];
  const form = new FormData();
  form.append('base64Image','data:image/png;base64,'+base64);
  form.append('language','kan+eng');
  form.append('isOverlayRequired','true');
  form.append('OCREngine','2'); // try engine 2
  form.append('apikey', key);
  log('Calling OCR.space (online) ...');
  const resp = await fetch('https://api.ocr.space/parse/image', { method:'POST', body: form });
  if (!resp.ok) throw new Error('OCR.space HTTP ' + resp.status);
  const j = await resp.json();
  if (j.IsErroredOnProcessing) throw new Error('OCR.space: ' + (j.ErrorMessage || 'error'));
  const parsed = (j.ParsedResults && j.ParsedResults[0]) ? j.ParsedResults[0] : null;
  if (!parsed) return { text:'', boxes:[] };
  const text = parsed.ParsedText || '';
  const boxes = parsed.TextOverlay && parsed.TextOverlay.Lines ? parsed.TextOverlay.Lines.map(L=>({
    text: L.Words.map(w=>w.WordText).join(' '),
    bbox: { x: L.Left, y: L.Top, w: L.Width, h: L.Height }
  })) : [];
  return { text, boxes };
}

/* Tesseract fallback with timeout */
async function tesseractRecognizeWithTimeout(dataUrl, timeoutMs=45000){
  log('Running Tesseract (client) ...');
  setProgress(0);
  const worker = Tesseract.createWorker({
    logger: m => {
      if (m.status) {
        if (m.status === 'recognizing text') {
          setProgress(Math.round(m.progress * 100));
        }
        log('Tesseract: ' + m.status + (m.progress ? ` ${Math.round(m.progress*100)}%` : ''));
      }
    }
  });

  let timer;
  try {
    await worker.load();
    await worker.loadLanguage('kan+eng');
    await worker.initialize('kan+eng');
    log('Tesseract initialized');

    // start recognition promise
    const recogPromise = worker.recognize(dataUrl);

    // timeout wrapper
    const result = await Promise.race([
      recogPromise,
      new Promise((_, rej) => timer = setTimeout(()=> rej(new Error('Tesseract timeout')), timeoutMs))
    ]);

    clearTimeout(timer);
    await worker.terminate();
    return result && result.data ? result.data : {};
  } catch (err) {
    try { await worker.terminate(); } catch(e){}
    throw err;
  }
}

/* wrapper to draw progress bar quickly */
function setProgress(p){ bar.style.width = Math.max(0,Math.min(100,p)) + '%'; }

/* transliterate with Aksharamukha (client) */
function transliterateLines(lines){
  try {
    return lines.map(l => ({ ...l, out: Aksharamukha.convert('Kannada','ISO', l.text || '') }));
  } catch(e){
    return lines.map(l => ({ ...l, out: l.text }));
  }
}

/* translate per-line using endpoint */
async function translateLines(lines, endpoint){
  const out = [];
  for (let i=0;i<lines.length;i++){
    const src = lines[i].text || lines[i].out || '';
    if (!src.trim()) { out.push({ ...lines[i], out: '' }); continue; }
    try {
      const resp = await fetch(endpoint, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ q: src, source:'kn', target:'en', format:'text' }) });
      const j = await resp.json();
      out.push({ ...lines[i], out: j.translatedText || (j.translation || src) });
    } catch(e){
      out.push({ ...lines[i], out: src });
    }
    await new Promise(r=>setTimeout(r,120));
    log(`Translating line ${i+1}/${lines.length}`);
  }
  return out;
}

/* build lines from boxes or tesseract data */
function buildLines(ocrResult, tesseractData){
  if (ocrResult && ocrResult.boxes && ocrResult.boxes.length) {
    return ocrResult.boxes.map(b => ({ text: b.text, bbox: b.bbox }));
  }
  if (tesseractData && tesseractData.lines && tesseractData.lines.length){
    return tesseractData.lines.map(ln=>{
      const b = ln.bbox || { x0: ln.x0 || 0, y0: ln.y0 || 0, x1: ln.x1 || 0, y1: ln.y1 || 0 };
      return { text: ln.text, bbox: { x: b.x0, y: b.y0, w: b.x1 - b.x0, h: b.y1 - b.y0 } };
    });
  }
  const fallback = (tesseractData && tesseractData.text) || (ocrResult && ocrResult.text) || '';
  return fallback ? [{ text: fallback, bbox: { x:10, y:10, w:200, h:30 } }] : [];
}

/* pipeline start */
async function startPipeline(file){
  try {
    if (!file) return;
    log(`File: ${file.name} (${Math.round(file.size/1024)} KB)`);

    // show preview
    const url = URL.createObjectURL(file);
    previewImg.src = url;
    previewImg.style.display = 'block';

    // load image element for preprocessing
    const img = new Image();
    img.src = url;
    await img.decode();

    // preprocess -> dataURL
    log('Preprocessing image (resize + contrast + sharpen) ...');
    const preDataUrl = await preprocessImage(img, 1000);

    // first try online OCR.space
    let ocrResult = null;
    try {
      ocrResult = await ocrSpaceRecognize(preDataUrl, ocrKeyEl.value);
      log('OCR.space returned length: ' + ((ocrResult && ocrResult.text) ? ocrResult.text.length : 0));
      if (ocrResult && ocrResult.text) log('OCR.space sample: ' + ocrResult.text.slice(0,200).replace(/\n/g,' '));
    } catch(e){
      log('OCR.space call failed: ' + e.message);
    }

    // if OCR.space not useful -> run Tesseract
    let tesseractData = null;
    if (!ocrResult || !isUsefulText(ocrResult.text)) {
      setProgress(5);
      try {
        const tRes = await tesseractRecognizeWithTimeout(preDataUrl, 45000);
        tesseractData = tRes || {};
        log('Tesseract text length: ' + ((tesseractData && tesseractData.text) ? tesseractData.text.length : 0));
        if (tesseractData && tesseractData.text) log('Tesseract sample: ' + (tesseractData.text||'').slice(0,200).replace(/\n/g,' '));
      } catch(err){
        log('Tesseract failed or timed out: ' + (err && err.message ? err.message : err));
      }
    }

    const finalText = (ocrResult && isUsefulText(ocrResult.text)) ? ocrResult.text : (tesseractData && isUsefulText(tesseractData.text) ? tesseractData.text : '');
    if (!isUsefulText(finalText)) {
      log('No useful text extracted. Try re-taking the photo with better lighting / closer crop / flatter paper.');
      setProgress(0);
      ocrTextEl.style.display = 'none';
      translitEl.style.display = 'none';
      transEl.style.display = 'none';
      return;
    }

    // build lines
    log('Building lines from OCR output ...');
    const lines = buildLines(ocrResult, tesseractData);

    // show extracted raw OCR
    ocrTextEl.style.display = 'block';
    ocrTextEl.value = (ocrResult && ocrResult.text) ? ocrResult.text : (tesseractData && tesseractData.text ? tesseractData.text : finalText);

    // transliterate
    log('Transliterating ...');
    const translit = transliterateLines(lines);
    translitEl.style.display = 'block';
    translitEl.value = translit.map(l=>l.out).join('\n');

    // translate if selected
    const endpoint = translateEndpointEl.value;
    if (endpoint && endpoint !== 'none') {
      log('Translating per-line via ' + endpoint);
      const translated = await translateLines(translit, endpoint);
      transEl.style.display = 'block';
      transEl.value = translated.map(l=>l.out).join('\n');
      log('Translation done.');
    } else {
      transEl.style.display = 'none';
      log('Translation skipped (endpoint = none).');
    }

    setProgress(100);
    log('Pipeline finished successfully.');
  } catch(e){
    log('Pipeline error: ' + (e && e.message ? e.message : String(e)));
    setProgress(0);
  }
}

/* wrapper to start from file object */
function startPipelineFile(file){ startPipeline(file); }

/* expose for debug */
window._startPipeline = startPipelineFile;

/* helper */
function setProgress(v){ setProgressBar(v); }
function setProgressBar(v){ bar.style.width = Math.max(0,Math.min(100,Math.round(v))) + '%'; }

/* initial */
log('Ready — drop an image in the top-left box.');

// end script
</script>
</body>
</html>
