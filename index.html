<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robust OCR (Kannada+English) — tries preproc+rotations+psm</title>

<!-- Tesseract -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:12px;background:#0f1720;color:#e6eef7}
  .wrap{max-width:980px;margin:0 auto}
  h1{font-size:20px}
  .grid{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:260px}
  .card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .box{background:#051025;padding:10px;border-radius:8px;min-height:80px;white-space:pre-wrap;font-family:monospace}
  input[type=file]{width:100%}
  button{padding:10px;border-radius:8px;border:0;background:linear-gradient(90deg,#ff6b81,#8a2be2);color:white;cursor:pointer}
  .muted{color:#9fb0c8;font-size:13px}
  .log{max-height:300px;overflow:auto;padding:8px;background:rgba(0,0,0,0.25);border-radius:8px;font-family:monospace;font-size:13px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .small{font-size:13px;color:#9fb0c8}
  .credits{font-family:Pacifico,cursive;text-align:right;margin-top:10px;color:rgba(255,255,255,0.9)}
  @media(max-width:820px){ .grid{flex-direction:column} }
</style>
</head>
<body>
<div class="wrap">
  <h1>Robust OCR → (Kannada + English) — Preprocess + Rotation + PSM attempt</h1>
  <div class="small">This version aggressively tries multiple preprocessing variants, small rotations and PSM modes, chooses the best OCR result, then attempts translation (fallback translators used).</div>

  <div style="margin-top:12px" class="grid">
    <div class="col card">
      <div class="small">Upload image (photo/screenshot)</div>
      <input id="file" type="file" accept="image/*"/>
      <div class="controls">
        <button id="startBtn">Start (auto on upload)</button>
        <button id="retryBtn">Retry last</button>
      </div>

      <div style="margin-top:10px" class="small">Preview</div>
      <img id="preview" style="width:100%;max-height:220px;object-fit:contain;border-radius:8px;margin-top:8px;display:none" />

      <div style="margin-top:10px" class="small">Pipeline Log</div>
      <div id="log" class="log">Idle.</div>
    </div>

    <div class="col card">
      <div class="small">OCR Best Result (mixed)</div>
      <div id="ocrOut" class="box"></div>

      <div style="margin-top:8px" class="controls">
        <button id="dlOcr">Download OCR</button>
        <button id="copyOcr">Copy OCR</button>
      </div>

      <div style="margin-top:12px" class="small">Translation (Kannada → English) — attempted only if good Kannada detected</div>
      <div id="transOut" class="box"></div>
      <div style="margin-top:8px" class="controls">
        <button id="dlTrans">Download Translation</button>
        <button id="tryTranslateBtn">Retry Translation</button>
      </div>

      <div class="credits">Created by Animesh</div>
    </div>
  </div>
</div>

<script>
/* === CONFIG === */
const ROTATIONS = [-2, 0, 2];           // degrees
const PREPROC_VARIANTS = ['contrast','sharpen','sauvola']; // simple set
const PSM_MODES = [3, 6];               // page segmentation modes to try
const OCR_TIMEOUT_MS = 20000;           // per recognition try
const EARLY_KANNADA_THRESHOLD = 20;     // if found >= this many Kannada chars -> accept early

// translators to try (POST endpoints expecting LibreTranslate payload)
const TRANSLATORS = [
  { name:'libretranslate.de', url:'https://libretranslate.de/translate' },
  { name:'argosopentech', url:'https://translate.argosopentech.com/translate' },
  { name:'astian', url:'https://translate.astian.org/translate' }
];

/* === DOM === */
const fileEl = document.getElementById('file');
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const ocrOut = document.getElementById('ocrOut');
const transOut = document.getElementById('transOut');
const dlOcr = document.getElementById('dlOcr');
const copyOcr = document.getElementById('copyOcr');
const dlTrans = document.getElementById('dlTrans');
const tryTranslateBtn = document.getElementById('tryTranslateBtn');

let lastFile = null;
let lastBest = null;
let workerInstance = null;

/* === HELPERS === */
function log(msg){ logEl.textContent = new Date().toLocaleTimeString() + ' — ' + msg + '\n' + logEl.textContent; console.log(msg); }
function setPreview(file){ preview.src = URL.createObjectURL(file); preview.style.display='block'; }
function countKannada(s){ const m = (''+s).match(/[\u0C80-\u0CFF]/g); return m ? m.length : 0; }
function isUseful(t){ return t && t.replace(/\s+/g,'').replace(/[0-9\W_]+/g,'').length >= 4; }

/* === IMAGE PREPROCESS === */

// Resize to max dimension
function resizeCanvas(img, maxDim=1600){
  const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
  const c = document.createElement('canvas');
  c.width = Math.round(img.width * scale);
  c.height = Math.round(img.height * scale);
  const ctx = c.getContext('2d');
  ctx.drawImage(img,0,0,c.width,c.height);
  return c;
}

// contrast stretch
function contrastStretchCanvas(c){
  const ctx = c.getContext('2d');
  const w=c.width,h=c.height;
  try {
    const id = ctx.getImageData(0,0,w,h);
    const d = id.data;
    let min=255,max=0;
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      if (lum<min) min=lum;
      if (lum>max) max=lum;
    }
    const range = Math.max(1,max-min);
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      const v = Math.round((lum-min)*255/range);
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){ log('contrast failed: '+e.message); }
  return c;
}

// unsharp mask (simple)
function sharpenCanvas(c){
  const ctx = c.getContext('2d');
  const w=c.width,h=c.height;
  try {
    // create blurred copy using canvas filter if supported
    const clone = document.createElement('canvas');
    clone.width=w; clone.height=h;
    const cctx = clone.getContext('2d');
    if (cctx.filter !== undefined) {
      cctx.filter = 'blur(1px)';
      cctx.drawImage(c,0,0);
      const idb = cctx.getImageData(0,0,w,h);
      const ida = ctx.getImageData(0,0,w,h);
      const da = ida.data, db = idb.data;
      for (let i=0;i<da.length;i+=4){
        // add 0.7*(original - blurred)
        let v = da[i] + 0.7*(da[i] - db[i]);
        v = Math.max(0,Math.min(255,Math.round(v)));
        da[i]=da[i+1]=da[i+2]=v;
      }
      ctx.putImageData(ida,0,0);
    } else {
      // fallback: increase contrast
      contrastStretchCanvas(c);
    }
  } catch(e){ log('sharpen failed: '+e.message); }
  return c;
}

// Sauvola adaptive threshold (approx)
function sauvolaBinarize(c){
  const ctx = c.getContext('2d');
  const w=c.width,h=c.height;
  try {
    const id = ctx.getImageData(0,0,w,h);
    const d = id.data;
    // compute grayscale intensity array
    const I = new Uint8ClampedArray((w*h));
    for (let i=0,j=0;i<d.length;i+=4,j++){ I[j] = Math.round(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]); }
    // windowed mean/std (window size 15)
    const ws = 15;
    const half = Math.floor(ws/2);
    const out = new Uint8ClampedArray(w*h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        let sum=0,sum2=0,cnt=0;
        for (let yy=Math.max(0,y-half); yy<=Math.min(h-1,y+half); yy++){
          for (let xx=Math.max(0,x-half); xx<=Math.min(w-1,x+half); xx++){
            const v = I[yy*w+xx];
            sum += v; sum2 += v*v; cnt++;
          }
        }
        const mean = sum / cnt;
        const varr = (sum2 / cnt) - (mean*mean);
        const std = Math.sqrt(Math.max(0,varr));
        const R = 128;
        const k = 0.34;
        const thresh = mean * (1 + k*((std / R) - 1));
        out[y*w+x] = I[y*w+x] > thresh ? 255 : 0;
      }
    }
    // write back
    for (let j=0,idx=0;j<d.length;j+=4,idx++){
      const v = out[idx];
      d[j]=d[j+1]=d[j+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){ log('sauvola failed: '+e.message); }
  return c;
}

// rotate canvas by degrees
function rotateCanvas(srcCanvas, deg){
  const r = deg * Math.PI / 180;
  const w = srcCanvas.width, h = srcCanvas.height;
  // compute new bbox
  const sin = Math.abs(Math.sin(r)), cos = Math.abs(Math.cos(r));
  const nw = Math.ceil(w * cos + h * sin);
  const nh = Math.ceil(w * sin + h * cos);
  const c = document.createElement('canvas');
  c.width = nw; c.height = nh;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,nw,nh);
  ctx.translate(nw/2, nh/2);
  ctx.rotate(r);
  ctx.drawImage(srcCanvas, -w/2, -h/2);
  return c;
}

/* === TESSERACT WORKER SETUP === */
async function getWorker(){
  if (workerInstance) return workerInstance;
  log('Initializing Tesseract worker (this may take a few seconds)...');
  const w = Tesseract.createWorker({
    logger: m => { /* keep silent here; we log per run */ }
  });
  await w.load();
  await w.loadLanguage('eng+kan');
  await w.initialize('eng+kan');
  workerInstance = w;
  log('Worker ready.');
  return w;
}

/* run recognition with timeout */
function recognizeWithTimeout(worker, dataUrl, psm, timeoutMs= OCR_TIMEOUT_MS){
  return new Promise(async (resolve, reject) => {
    let timed = false;
    const timer = setTimeout(()=>{ timed = true; reject(new Error('recognize timeout')); }, timeoutMs);
    try {
      // set psm by command
      await worker.setParameters({ tessedit_pageseg_mode: psm });
      const res = await worker.recognize(dataUrl);
      if (!timed) { clearTimeout(timer); resolve(res.data); }
    } catch(err){
      if (!timed) { clearTimeout(timer); reject(err); }
    }
  });
}

/* === pipeline main: tries combinations, early stop on good result === */
async function runPipeline(file){
  lastFile = file;
  log('Starting pipeline for file: ' + file.name);
  setPreview(file);
  ocrOut.textContent = '';
  transOut.textContent = '';

  const img = new Image();
  img.src = URL.createObjectURL(file);
  await img.decode();

  // prepare base canvas
  const base = resizeCanvas(img, 1600);

  const worker = await getWorker();

  let best = { score:-1, text:'', variant:null, details:null };

  // build variant canvases (no rotation yet)
  const variantCanvases = [];
  for (const v of PREPROC_VARIANTS){
    const c = document.createElement('canvas');
    c.width = base.width; c.height = base.height;
    c.getContext('2d').drawImage(base,0,0);
    if (v === 'contrast') contrastStretchCanvas(c);
    if (v === 'sharpen'){ contrastStretchCanvas(c); sharpenCanvas(c); }
    if (v === 'sauvola'){ contrastStretchCanvas(c); sauvolaBinarize(c); }
    variantCanvases.push({name:v, canvas:c});
  }

  // try rotations + variants + psm
  outer:
  for (const rot of ROTATIONS){
    for (const vObj of variantCanvases){
      // rotate canvas copy
      const rotCanvas = (rot === 0) ? vObj.canvas : rotateCanvas(vObj.canvas, rot);
      const dataUrl = rotCanvas.toDataURL('image/png');

      for (const psm of PSM_MODES){
        log(`Trying variant=${vObj.name}, rot=${rot}°, psm=${psm}`);
        try {
          // run OCR with timeout
          const data = await recognizeWithTimeout(worker, dataUrl, psm, OCR_TIMEOUT_MS);
          const text = (data && data.text) ? data.text.trim() : '';
          const kannadaCount = countKannada(text);
          const usefulScore = (kannadaCount * 3) + text.replace(/\s+/g,'').length; // heuristic
          log(`Result: len=${text.length}, kannada=${kannadaCount}, score=${usefulScore}`);
          if (usefulScore > best.score){
            best = { score:usefulScore, text, variant:vObj.name, rot, psm, raw:data };
            // update UI with interim best
            ocrOut.textContent = best.text;
          }
          // early accept if Kannada count high enough:
          if (kannadaCount >= EARLY_KANNADA_THRESHOLD){
            log('Early-accept: sufficient Kannada characters.');
            break outer;
          }
        } catch(err){
          log(`OCR failed for variant ${vObj.name} rot ${rot} psm ${psm}: ${err.message}`);
        }
      }
    }
  }

  if (!best.text || !isUseful(best.text)){
    log('No useful OCR text found after trying all variants.');
    ocrOut.textContent = best.text || '(no text)';
    transOut.textContent = 'No Kannada detected to translate (improve photo: lighting, closer crop).';
    return;
  }

  // best found
  lastBest = best;
  ocrOut.textContent = best.text;
  log(`Selected best: variant=${best.variant}, rot=${best.rot}°, psm=${best.psm}, score=${best.score}`);

  // extract Kannada segments for translation
  const kannadaChunks = (best.text.match(/[\u0C80-\u0CFF][^\n\r]*/g) || []).join("\n").trim();
  if (!kannadaChunks){
    log('No Kannada chars detected in best OCR text.');
    transOut.textContent = 'No Kannada detected to translate.';
    return;
  }

  transOut.textContent = 'Translating Kannada chunks...';
  // try translators
  const translation = await translateWithFallback(kannadaChunks);
  if (translation.success){
    transOut.textContent = translation.text + '\n\n(used: ' + translation.source + ')';
    lastTranslation = translation.text;
  } else {
    transOut.textContent = 'Translation failed (all endpoints failed). See log.';
  }
}

/* translation with fallbacks */
async function translateWithFallback(text){
  const body = { q: text, source:'kn', target:'en', format:'text' };
  for (const ep of TRANSLATORS){
    log(`Trying translator: ${ep.name} (${ep.url})`);
    try {
      const res = await fetchWithTimeout(ep.url, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify(body)
      }, 9000);
      if (!res.ok){ log(`${ep.name} HTTP ${res.status}`); continue; }
      const j = await res.json();
      // extract translated text where possible
      const translated = j.translatedText || j.translation || j.result || (j[0] && j[0].map? j[0].map(x=>x[0]).join('') : null);
      if (translated && translated.trim().length){
        return { success:true, text:translated, source:ep.name, raw:j };
      } else {
        log(`${ep.name} returned empty translation`);
      }
    } catch(e){
      log(`${ep.name} failed: ${e.message}`);
    }
  }
  return { success:false };
}

/* wrapper for fetch with timeout */
function fetchWithTimeout(url, opts={}, ms=8000){
  return new Promise((resolve,reject)=>{
    const timer = setTimeout(()=> reject(new Error('timeout')), ms);
    fetch(url, opts).then(r=>{ clearTimeout(timer); resolve(r); }).catch(err=>{ clearTimeout(timer); reject(err); });
  });
}

/* === UI wiring === */
fileEl.addEventListener('change', (e)=>{ const f = e.target.files[0]; if (f){ lastFile = f; setPreview(f); runPipeline(f); }});
startBtn.addEventListener('click', ()=>{ if (fileEl.files[0]) runPipeline(fileEl.files[0]); else alert('Choose a file first'); });
retryBtn.addEventListener('click', ()=>{ if (lastFile) runPipeline(lastFile); else alert('No previous file'); });
dlOcr.addEventListener('click', ()=>{ if (!lastBest) return alert('No OCR'); downloadText('ocr.txt', lastBest.text); });
copyOcr.addEventListener('click', ()=>{ if (!lastBest) return alert('No OCR'); navigator.clipboard.writeText(lastBest.text).then(()=> alert('Copied OCR')); });
dlTrans.addEventListener('click', ()=>{ if (!lastTranslation) return alert('No translation'); downloadText('translation.txt', lastTranslation); });
tryTranslateBtn.addEventListener('click', async ()=>{ if (!lastBest) return alert('No OCR text'); const kannadaChunks = (lastBest.text.match(/[\u0C80-\u0CFF][^\n\r]*/g) || []).join('\n').trim(); if (!kannadaChunks) return alert('No Kannada detected'); const res = await translateWithFallback(kannadaChunks); if (res.success){ transOut.textContent = res.text + '\n\n(used: ' + res.source + ')'; lastTranslation = res.text; } else { alert('Translation failed (endpoints blocked)'); }});

function downloadText(filename, text){ const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([text],{type:'text/plain'})); a.download = filename; a.click(); }

/* initial */
log('Ready. Upload an image with Kannada + English. The page will try variants & rotations to get best OCR.');
</script>
</body>
</html>
