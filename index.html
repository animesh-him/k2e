<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Kannada + English OCR → Translation (chunked & fallback)</title>

<!-- Tesseract v5 -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
  :root{
    --bg:#06070a; --card:#0e1720; --muted:#9fb0c8; --accent1:#ff6b81; --accent2:#8a2be2; --text:#e6eef7;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#03040a,#071021);color:var(--text);font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{max-width:980px;margin:16px auto;padding:14px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  h1{margin:0;font-size:20px}
  .lead{color:var(--muted);font-size:13px;margin-top:6px}
  .grid{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
  .col{flex:1;min-width:280px}
  .card{padding:12px;border-radius:10px;background:var(--card);border:1px solid rgba(255,255,255,0.02)}
  input[type=file]{width:100%}
  .preview{width:100%;max-height:320px;object-fit:contain;border-radius:8px;background:#fff;margin-top:8px;display:none}
  .box{width:100%;min-height:120px;border-radius:8px;padding:10px;background:#071018;color:var(--text);font-family:monospace;white-space:pre-wrap;overflow:auto}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{padding:10px 12px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:white;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
  .small{font-size:13px;color:var(--muted)}
  .log{max-height:220px;overflow:auto;padding:10px;background:rgba(0,0,0,0.25);border-radius:8px;font-family:monospace;font-size:13px}
  .credits{font-family:Pacifico,cursive;text-align:right;margin-top:10px;color:rgba(255,255,255,0.9)}
  @media(max-width:820px){ .grid{flex-direction:column} .col{min-width:unset} }
</style>
</head>
<body>
  <div class="wrap">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h1>Kannada + English OCR → English Translation</h1>
        <div class="lead">Robust pipeline: preprocessing, separate OCR (kan & eng), chunked translation + fallbacks</div>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="col card">
        <div class="small">Upload image (photo / screenshot). Processing starts automatically.</div>
        <input id="fileInput" type="file" accept="image/*" style="margin-top:8px"/>
        <div style="margin-top:10px" class="controls">
          <button id="processBtn" class="secondary">Process Now</button>
          <button id="retryBtn" class="secondary">Retry last</button>
        </div>

        <img id="preview" class="preview" alt="preview"/>

        <div style="margin-top:10px" class="small">Pipeline Log</div>
        <div id="log" class="log">Idle. Upload an image to start.</div>
      </div>

      <div class="col card">
        <div class="small">OCR Combined Output (Kannada first + English)</div>
        <div id="ocrBox" class="box">(OCR results will appear here)</div>
        <div class="controls" style="margin-top:8px">
          <button id="downloadOcr" class="secondary">Download OCR</button>
          <button id="copyOcr" class="secondary">Copy OCR</button>
        </div>

        <div style="margin-top:12px" class="small">English Translation (chunks & fallback)</div>
        <div id="transBox" class="box">(Translation will appear here)</div>
        <div class="controls" style="margin-top:8px">
          <button id="downloadTrans" class="secondary">Download Translation</button>
          <button id="retryTrans" class="secondary">Retry Translation</button>
        </div>

        <div class="credits">Created by Animesh</div>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   CONFIG
   --------------------------- */
const ROTATIONS = [-2, 0, 2]; // degrees to try (small)
const MAX_DIM = 1600;         // max dimension for resize
const CHUNK_SIZE = 400;       // safe translation chunk (~<500 limit)
const OCR_TIMEOUT = 20000;    // ms per recognition
const TRANSLATION_TIMEOUT = 9000; // per request ms

// translator endpoints (order = priority)
const TRANSLATORS = [
  { name: 'MyMemory', kind: 'get', build: t => `https://api.mymemory.translated.net/get?q=${encodeURIComponent(t)}&langpair=kn|en` },
  { name: 'libretranslate.de', kind: 'post', url: 'https://libretranslate.de/translate' },
  { name: 'argosopentech', kind: 'post', url: 'https://translate.argosopentech.com/translate' },
  { name: 'astian', kind: 'post', url: 'https://translate.astian.org/translate' }
];

/* ---------------------------
   DOM
   --------------------------- */
const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const retryBtn = document.getElementById('retryBtn');
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const ocrBox = document.getElementById('ocrBox');
const transBox = document.getElementById('transBox');
const downloadOcr = document.getElementById('downloadOcr');
const copyOcr = document.getElementById('copyOcr');
const downloadTrans = document.getElementById('downloadTrans');
const retryTrans = document.getElementById('retryTrans');

let lastFile = null;
let lastCombinedText = '';
let lastTranslation = '';
let workerKan = null;
let workerEng = null;

/* ---------------------------
   LOGGING & HELPERS
   --------------------------- */
function log(msg){
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `${ts} — ${msg}\n` + logEl.textContent;
  console.log(msg);
}
function showOcr(t){ ocrBox.textContent = t || '(no text)'; }
function showTrans(t){ transBox.textContent = t || '(no translation)'; }
function downloadText(filename, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text||''], { type: 'text/plain' }));
  a.download = filename;
  a.click();
}
function copyText(text){
  navigator.clipboard?.writeText(text).then(()=> alert('Copied to clipboard'), ()=> alert('Copy failed'));
}
function dataUrlFromCanvas(c){ return c.toDataURL('image/png'); }

/* ---------------------------
   IMAGE PREPROCESSING
   --------------------------- */

// resize to max dimension
function resizeCanvas(img, maxDim=MAX_DIM){
  const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
  const c = document.createElement('canvas');
  c.width = Math.round(img.width * scale);
  c.height = Math.round(img.height * scale);
  const ctx = c.getContext('2d');
  ctx.drawImage(img, 0, 0, c.width, c.height);
  return c;
}

// contrast stretch
function contrastStretch(c){
  try {
    const ctx = c.getContext('2d');
    const id = ctx.getImageData(0,0,c.width,c.height);
    const d = id.data;
    let min=255, max=0;
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      if (lum<min) min=lum;
      if (lum>max) max=lum;
    }
    const range = Math.max(1, max-min);
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      const v = Math.round((lum - min) * 255 / range);
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){ log('contrast error: '+e.message); }
  return c;
}

// simple sharpen (unsharp-like)
function sharpen(c){
  try {
    const ctx = c.getContext('2d');
    // use canvas filter if available for blur -> combine
    const clone = document.createElement('canvas');
    clone.width = c.width; clone.height = c.height;
    const cctx = clone.getContext('2d');
    if (cctx.filter !== undefined){
      cctx.filter = 'blur(1px)';
      cctx.drawImage(c,0,0);
      const idBlur = cctx.getImageData(0,0,c.width,c.height);
      const id = ctx.getImageData(0,0,c.width,c.height);
      const db = idBlur.data, da = id.data;
      for (let i=0;i<da.length;i+=4){
        // emphasize difference
        let v = da[i] + 0.6*(da[i] - db[i]);
        v = Math.max(0, Math.min(255, Math.round(v)));
        da[i]=da[i+1]=da[i+2]=v;
      }
      ctx.putImageData(id,0,0);
    } else {
      contrastStretch(c);
    }
  } catch(e){ log('sharpen error: '+e.message); }
  return c;
}

// sauvola-ish adaptive binarization (approx, heavy but optional)
function sauvola(c){
  try {
    const ctx = c.getContext('2d');
    const w = c.width, h = c.height;
    const id = ctx.getImageData(0,0,w,h);
    const d = id.data;
    const I = new Uint8ClampedArray(w*h);
    for (let i=0,j=0;i<d.length;i+=4,j++){ I[j] = Math.round(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]); }
    const ws = 15, half = Math.floor(ws/2);
    const out = new Uint8ClampedArray(w*h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        let sum=0,sum2=0,cnt=0;
        for (let yy=Math.max(0,y-half); yy<=Math.min(h-1,y+half); yy++){
          for (let xx=Math.max(0,x-half); xx<=Math.min(w-1,x+half); xx++){
            const v = I[yy*w+xx];
            sum += v; sum2 += v*v; cnt++;
          }
        }
        const mean = sum / cnt;
        const varr = (sum2 / cnt) - (mean*mean);
        const std = Math.sqrt(Math.max(0, varr));
        const R = 128;
        const k = 0.34;
        const thresh = mean * (1 + k*((std / R) - 1));
        out[y*w + x] = I[y*w + x] > thresh ? 255 : 0;
      }
    }
    for (let j=0,idx=0;j<d.length;j+=4,idx++){
      const v = out[idx];
      d[j]=d[j+1]=d[j+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){ log('sauvola error: '+e.message); }
  return c;
}

// rotate canvas by deg
function rotateCanvas(src, deg){
  const r = deg * Math.PI / 180;
  const w = src.width, h = src.height;
  const sin = Math.abs(Math.sin(r)), cos = Math.abs(Math.cos(r));
  const nw = Math.ceil(w * cos + h * sin);
  const nh = Math.ceil(w * sin + h * cos);
  const c = document.createElement('canvas');
  c.width = nw; c.height = nh;
  const ctx = c.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0,0,nw,nh);
  ctx.translate(nw/2, nh/2);
  ctx.rotate(r);
  ctx.drawImage(src, -w/2, -h/2);
  return c;
}

/* ---------------------------
   TESSERACT WORKERS (kan, eng)
   --------------------------- */
async function getWorkerForLang(lang){
  if (lang === 'kan'){
    if (workerKan) return workerKan;
    log('Initializing Kannada worker...');
    workerKan = Tesseract.createWorker({ logger: m => {/*silent*/} });
    await workerKan.load();
    await workerKan.loadLanguage('kan');
    await workerKan.initialize('kan');
    await workerKan.setParameters({ tessedit_pageseg_mode: '6' }); // assume block of text
    log('Kannada worker ready.');
    return workerKan;
  } else {
    if (workerEng) return workerEng;
    log('Initializing English worker...');
    workerEng = Tesseract.createWorker({ logger: m => {/*silent*/} });
    await workerEng.load();
    await workerEng.loadLanguage('eng');
    await workerEng.initialize('eng');
    await workerEng.setParameters({ tessedit_pageseg_mode: '6' });
    log('English worker ready.');
    return workerEng;
  }
}

function recognizeWithTimeout(worker, dataUrl, timeout=OCR_TIMEOUT){
  return new Promise(async (resolve, reject) => {
    let timed = false;
    const timer = setTimeout(()=>{ timed = true; reject(new Error('OCR timeout')); }, timeout);
    try {
      const res = await worker.recognize(dataUrl);
      if (!timed){ clearTimeout(timer); resolve(res.data); }
    } catch(err){
      if (!timed){ clearTimeout(timer); reject(err); }
    }
  });
}

/* ---------------------------
   MAIN PIPELINE
   --------------------------- */
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if (f){ lastFile = f; preview.src = URL.createObjectURL(f); preview.style.display='block'; runPipeline(f); }
});
processBtn.addEventListener('click', ()=>{ if (fileInput.files[0]) runPipeline(fileInput.files[0]); else alert('Choose a file first'); });
retryBtn.addEventListener('click', ()=>{ if (lastFile) runPipeline(lastFile); else alert('No previous file'); });
retryTrans.addEventListener('click', ()=>{ if (lastCombinedText) doTranslationChunks(lastCombinedText); else alert('No OCR text'); });
downloadOcr.addEventListener('click', ()=> downloadText('ocr.txt', lastCombinedText));
copyOcr.addEventListener('click', ()=> copyText(lastCombinedText));
downloadTrans.addEventListener('click', ()=> downloadText('translation.txt', lastTranslation));

async function runPipeline(file){
  try {
    log('Starting pipeline for file: ' + file.name);
    showOcr('(processing...)'); showTrans('(waiting...)');
    const img = new Image();
    img.src = URL.createObjectURL(file);
    await img.decode();

    // base canvas
    const base = resizeCanvas(img, MAX_DIM);
    // prepare variants: plain, contrast+sharpen, contrast+sauvola
    const variants = [];
    // plain
    const plain = document.createElement('canvas'); plain.width = base.width; plain.height = base.height;
    plain.getContext('2d').drawImage(base,0,0); variants.push({name:'plain', canvas:plain});
    // contrast+sharpen
    const cs = document.createElement('canvas'); cs.width = base.width; cs.height = base.height; cs.getContext('2d').drawImage(base,0,0);
    contrastStretch(cs); sharpen(cs); variants.push({name:'contrast_sharp', canvas:cs});
    // contrast+sauvola
    const sa = document.createElement('canvas'); sa.width = base.width; sa.height = base.height; sa.getContext('2d').drawImage(base,0,0);
    contrastStretch(sa); sauvola(sa); variants.push({name:'contrast_sauvola', canvas:sa});

    // run separate OCR flows: first Kannada across rotations+variants, select best
    const kanWorker = await getWorkerForLang('kan');
    let bestKan = {score:-1, text:'', details:null};

    for (const rot of ROTATIONS){
      for (const v of variants){
        const canvas = (rot === 0) ? v.canvas : rotateCanvas(v.canvas, rot);
        const url = dataUrlFromCanvas(canvas);
        log(`Trying KAN variant=${v.name} rot=${rot}°`);
        try {
          const data = await recognizeWithTimeout(kanWorker, url);
          const text = (data && data.text) ? data.text.trim() : '';
          const kcount = (text.match(/[\u0C80-\u0CFF]/g) || []).length;
          const score = kcount*3 + text.replace(/\s+/g,'').length;
          log(`KAN result len=${text.length} kannada=${kcount} score=${score}`);
          if (score > bestKan.score){ bestKan = {score, text, details:{variant:v.name, rot}}; showOcr(bestKan.text); }
          if (kcount >= 20){ log('KAN early accept'); rot = 999; break; } // early exit
        } catch(e){
          log(`KAN failed for variant ${v.name} rot ${rot}: ${e.message}`);
        }
      }
    }

    // English OCR (use plain/resized + small rotation) — we can be quicker
    const engWorker = await getWorkerForLang('eng');
    let bestEng = {score:-1, text:'', details:null};
    for (const rot of ROTATIONS){
      const canvas = (rot === 0) ? plain : rotateCanvas(plain, rot);
      const url = dataUrlFromCanvas(canvas);
      log(`Trying ENG rot=${rot}°`);
      try {
        const data = await recognizeWithTimeout(engWorker, url);
        const text = (data && data.text) ? data.text.trim() : '';
        const score = text.replace(/\s+/g,'').length;
        log(`ENG result len=${text.length} score=${score}`);
        if (score > bestEng.score){ bestEng = {score, text, details:{rot}}; }
        if (score > 30) break;
      } catch(e){
        log(`ENG failed rot ${rot}: ${e.message}`);
      }
    }

    // combine
    const kanText = bestKan.text || '';
    const engText = bestEng.text || '';
    const combined = (kanText + "\n" + engText).trim();
    lastCombinedText = combined;
    showOcr(combined || '(no OCR result)');
    log(`Selected KAN variant=${bestKan.details?.variant || 'n/a'} rot=${bestKan.details?.rot || 0} score=${bestKan.score}`);
    log(`Selected ENG rot=${bestEng.details?.rot || 0} score=${bestEng.score}`);

    // if no Kannada found, let user know and still attempt translation of whatever exists
    const kcountTotal = (combined.match(/[\u0C80-\u0CFF]/g) || []).length;
    if (kcountTotal < 4 && combined.length < 10){
      log('No useful Kannada or English extracted. Try re-taking photo (closer, flatter, better lighting).');
      showTrans('No translation: no useful OCR text.');
      return;
    }

    // translation: chunk Kannada-containing text (we will translate all combined text but chunk safely)
    await doTranslationChunks(combined);

  } catch(err){
    log('Pipeline error: ' + (err && err.message || String(err)));
    showOcr('(pipeline error)');
    showTrans('(pipeline error)');
  }
}

/* ---------------------------
   TRANSLATION (chunking + fallback)
   --------------------------- */

// split into chunks of up to approx CHUNK_SIZE chars, attempting sentence/line boundaries
function chunkText(text, maxLen=CHUNK_SIZE){
  const paragraphs = text.split(/\n{2,}/g);
  const chunks = [];
  for (const p of paragraphs){
    if (!p.trim()) continue;
    let remaining = p.trim();
    while (remaining.length > 0){
      if (remaining.length <= maxLen){ chunks.push(remaining); break; }
      // try to split at last sentence boundary before maxLen
      const sub = remaining.slice(0, maxLen);
      const lastDot = sub.lastIndexOf('.') || sub.lastIndexOf('।') || sub.lastIndexOf('?') || sub.lastIndexOf('!');
      const lastNL = sub.lastIndexOf('\n');
      const splitPos = Math.max(lastNL, lastDot);
      if (splitPos > Math.floor(maxLen*0.6)){
        chunks.push(remaining.slice(0, splitPos+1).trim());
        remaining = remaining.slice(splitPos+1).trim();
      } else {
        // fallback: split at whitespace
        const lastSpace = sub.lastIndexOf(' ');
        const cut = (lastSpace > 50) ? lastSpace : maxLen;
        chunks.push(remaining.slice(0, cut).trim());
        remaining = remaining.slice(cut).trim();
      }
    }
  }
  // if empty but text existed, push small chunks
  if (chunks.length === 0 && text.trim()) chunks.push(text.trim().slice(0, maxLen));
  return chunks;
}

// try a translator for a single chunk
async function translateChunkWithEndpoint(chunk, ep){
  try {
    if (ep.kind === 'get'){ // MyMemory
      const url = ep.build(chunk);
      const res = await fetchWithTimeout(url, {}, TRANSLATION_TIMEOUT);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const j = await res.json();
      // MyMemory returns responseData.translatedText
      const t = j.responseData && j.responseData.translatedText;
      if (t && t.trim()) return { ok:true, text:t, source:ep.name };
      return { ok:false };
    } else { // POST format (Libre-like)
      const res = await fetchWithTimeout(ep.url, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ q: chunk, source: 'kn', target: 'en', format: 'text' })
      }, TRANSLATION_TIMEOUT);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const j = await res.json();
      // try different shapes
      const t = j.translatedText || j.translated_text || j.translation || (j.result && j.result[0] && j.result[0][0]) || null;
      if (t && t.trim()) return { ok:true, text: t, source:ep.name };
      return { ok:false };
    }
  } catch(e){
    log(`${ep.name} failed: ${e.message}`);
    return { ok:false };
  }
}

// translate the full text by chunking and trying endpoints for each chunk
async function doTranslationChunks(fullText){
  try {
    showTrans('Translating…');
    log('Preparing translation chunks...');
    const chunks = chunkText(fullText, CHUNK_SIZE);
    log(`Chunks created: ${chunks.length}`);

    const results = [];
    for (let i=0;i<chunks.length;i++){
      const chunk = chunks[i];
      log(`Translating chunk ${i+1}/${chunks.length} (len=${chunk.length})`);
      let translated = null;
      // try translators in order
      for (const ep of TRANSLATORS){
        const res = await translateChunkWithEndpoint(chunk, ep);
        if (res.ok){ translated = res.text; log(`Chunk ${i+1} translated by ${res.source}`); break; }
      }
      if (!translated){
        // if all endpoints failed, put placeholder
        translated = '[Translation unavailable for this chunk]';
        log(`Chunk ${i+1} translation failed on all endpoints.`);
      }
      results.push(translated);
      // tiny pause to be polite
      await new Promise(r => setTimeout(r, 200));
    }

    const final = results.join('\n\n');
    lastTranslation = final;
    showTrans(final);
    log('Translation complete.');
  } catch(e){
    log('Translation pipeline error: '+(e && e.message));
    showTrans('Translation failed.');
  }
}

/* ---------------------------
   small fetch timeout helper
   --------------------------- */
function fetchWithTimeout(url, opts={}, ms=8000){
  return new Promise((resolve,reject)=>{
    const timer = setTimeout(()=> reject(new Error('timeout')), ms);
    fetch(url, opts).then(r=>{ clearTimeout(timer); resolve(r); }).catch(err=>{ clearTimeout(timer); reject(err); });
  });
}

/* ---------------------------
   cleanup on page unload (terminate workers)
   --------------------------- */
window.addEventListener('beforeunload', async ()=>{
  try { if (workerKan) await workerKan.terminate(); if (workerEng) await workerEng.terminate(); } catch(e){}
});

/* ---------------------------
   initial log
   --------------------------- */
log('Ready. Upload an image (Kannada + English). Processing starts automatically.');

</script>
</body>
</html>
