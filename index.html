<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robust OCR + Translation (Kannada → English)</title>

<!-- Tesseract (worker) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>

<style>
  :root{ --bg:#071021; --card:#0f1720; --muted:#9fb0c8; --txt:#e6eef7; --accent:#ff6b81;}
  body{ margin:0; font-family:Inter,Arial,Helvetica,sans-serif; background:linear-gradient(180deg,var(--bg),#04050a); color:var(--txt); }
  .wrap{max-width:980px;margin:14px auto;padding:14px}
  h1{margin:0 0 8px 0}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:220px}
  .card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  input[type=file]{width:100%}
  .box{background:#0b1220;border-radius:8px;padding:10px;min-height:72px;white-space:pre-wrap;color:var(--txt);font-size:14px}
  button{padding:10px;border-radius:8px;border:0;background:linear-gradient(90deg,var(--accent),#8a2be2);color:white;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .log{max-height:260px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-family:monospace;font-size:12px}
  .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .small{font-size:13px;color:var(--muted)}
  .credits{font-family:Pacifico,cursive;text-align:right;margin-top:12px;color:rgba(255,255,255,0.9)}
  @media(max-width:820px){ .row{flex-direction:column} }
</style>
</head>
<body>
<div class="wrap">
  <h1>Robust OCR → Kannada → English (retrying translators)</h1>
  <div class="small">Preprocess + multiple OCR variants → picks best result → retries multiple translators automatically.</div>

  <div class="row" style="margin-top:12px">
    <div class="col card">
      <div class="small">Upload / Drop Image</div>
      <input id="file" type="file" accept="image/*"/>
      <div class="muted" style="margin-top:8px">Processing starts automatically after upload.</div>
      <div class="controls">
        <button id="runAgain">Retry OCR+Translate</button>
        <button id="copyOcr" class="secondary">Copy OCR</button>
        <button id="downloadOcr" class="secondary">Download OCR</button>
      </div>
      <div style="margin-top:8px">
        <div class="small">Preview</div>
        <img id="preview" style="width:100%;max-height:240px;object-fit:contain;border-radius:8px;margin-top:8px;display:none" />
      </div>
    </div>

    <div class="col card">
      <div class="small">Pipeline Log</div>
      <div id="log" class="log">Idle.</div>
      <div style="margin-top:8px">
        <div class="small">Progress</div>
        <div style="height:10px;background:#111;border-radius:6px;margin-top:6px;overflow:hidden"><div id="bar" style="height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#8a2be2)"></div></div>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="col card">
      <div class="small">OCR Output (mixed Kannada + English)</div>
      <div id="ocrOut" class="box"></div>
      <div class="controls">
        <button id="downloadOcrFile">Download OCR .txt</button>
        <button id="showVariants">Show OCR Variants</button>
      </div>
    </div>

    <div class="col card">
      <div class="small">Translation (Kannada → English)</div>
      <div id="translationOut" class="box"></div>
      <div class="controls">
        <button id="downloadTransFile">Download Translation</button>
      </div>
      <div class="small" style="margin-top:8px">If translation fails, the app automatically retries alternate public endpoints.</div>
    </div>
  </div>

  <div class="credits">Created by Animesh</div>
</div>

<script>
/* Robust OCR + multiple translator retries
   - Preprocess image into two variants (base, enhanced)
   - Run Tesseract on each variant, score by Kannada-character count + length
   - Pick best OCR text and show
   - Extract Kannada-only segments and translate them
   - Try multiple translation endpoints with timeouts
*/

// DOM
const fileEl = document.getElementById('file');
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const bar = document.getElementById('bar');
const ocrOut = document.getElementById('ocrOut');
const translationOut = document.getElementById('translationOut');
const runAgainBtn = document.getElementById('runAgain');
const downloadOcrFileBtn = document.getElementById('downloadOcrFile');
const downloadTransFileBtn = document.getElementById('downloadTransFile');
const copyOcrBtn = document.getElementById('copyOcr');
const downloadOcrBtn = document.getElementById('downloadOcr');

let lastFile = null;
let lastOcr = '';
let lastTranslation = '';

// Translation endpoints to try in order:
const TRANSLATE_ENDPOINTS = [
  { url: 'https://libretranslate.de/translate', name:'libretranslate.de' },
  { url: 'https://translate.argosopentech.com/translate', name:'argosopentech' },
  { url: 'https://translate.astian.org/translate', name:'astian' }
];

// helpers
function log(msg){ logEl.textContent = new Date().toLocaleTimeString() + ' — ' + msg + '\n' + logEl.textContent; console.log(msg); }
function setProgress(p){ bar.style.width = Math.max(0,Math.min(100,p)) + '%'; }
function isUsefulText(t){ return t && t.replace(/\s+/g,'').replace(/[0-9\W_]+/g,'').length >= 3; }
function countKannadaChars(s){ const m = s.match(/[\u0C80-\u0CFF]/g); return m ? m.length : 0; }

// image preprocessing: returns dataURL
function resizeCanvas(img, scaleMax=1200){
  const max = scaleMax;
  const scale = Math.min(1, max / Math.max(img.width, img.height));
  const c = document.createElement('canvas');
  c.width = Math.round(img.width * scale);
  c.height = Math.round(img.height * scale);
  const ctx = c.getContext('2d');
  ctx.drawImage(img,0,0,c.width,c.height);
  return c;
}
function contrastStretchCanvas(canvas){
  const ctx = canvas.getContext('2d');
  const w=canvas.width,h=canvas.height;
  try {
    const id = ctx.getImageData(0,0,w,h);
    const d = id.data;
    let min=255,max=0;
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      if (lum<min) min=lum;
      if (lum>max) max=lum;
    }
    const range = Math.max(1,max-min);
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      const v = Math.round((lum-min)*255/range);
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){
    log('contrast adjust failed: '+e.message);
  }
  return canvas;
}
function binarizeCanvas(canvas){
  const ctx = canvas.getContext('2d');
  const w=canvas.width,h=canvas.height;
  try {
    const id = ctx.getImageData(0,0,w,h);
    const d = id.data;
    // compute simple global threshold (Otsu-like approximate)
    let sum=0,sum2=0;
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      sum += lum; sum2 += lum*lum;
    }
    const n = (d.length/4);
    const mean = sum / n;
    let threshold = mean * 0.9;
    for (let i=0;i<d.length;i+=4){
      const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      const v = lum > threshold ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){
    log('binarize failed: '+e.message);
  }
  return canvas;
}

// run OCR on a dataURL using tesseract worker
async function runTesseract(dataUrl, progressCallback){
  setProgress(0);
  const worker = Tesseract.createWorker({
    logger: m => {
      if (m.status && m.progress != null) {
        progressCallback && progressCallback(m);
        setProgress(Math.round(m.progress*100));
      }
    }
  });
  await worker.load();
  await worker.loadLanguage('eng+kan'); // multilingual
  await worker.initialize('eng+kan');
  // set PSM to AUTO (default)
  const res = await worker.recognize(dataUrl);
  await worker.terminate();
  return res.data || {};
}

// Choose best OCR among variants
async function bestOcrFromFile(file){
  log('Preparing image variants...');
  const img = new Image();
  img.src = URL.createObjectURL(file);
  await img.decode();
  preview.src = img.src; preview.style.display='block';

  // variant A: resized + contrast
  const cA = resizeCanvas(img, 1200);
  contrastStretchCanvas(cA);
  const dataA = cA.toDataURL('image/png');

  // variant B: resized + contrast + binarize
  const cB = resizeCanvas(img, 1200);
  contrastStretchCanvas(cB);
  binarizeCanvas(cB);
  const dataB = cB.toDataURL('image/png');

  const variants = [
    { name:'contrast', data: dataA },
    { name:'binarize', data: dataB }
  ];

  let best = {score:-1, text:'', variant:null, raw:null};
  for (let i=0;i<variants.length;i++){
    const v = variants[i];
    log(`OCR variant: ${v.name} → starting`);
    try {
      const res = await runTesseract(v.data, m => {
        // show small log
      });
      const text = (res.text || '').trim();
      const kannadaCount = countKannadaChars(text);
      const usefulScore = (kannadaCount * 2) + text.replace(/\s+/g,'').length; // heuristic
      log(`Variant ${v.name}: len=${text.length}, kannada=${kannadaCount}, score=${usefulScore}`);
      if (usefulScore > best.score){
        best = { score:usefulScore, text, variant:v.name, raw:res };
      }
    } catch(e){
      log(`Variant ${v.name} failed: ${e.message}`);
    }
  }
  return best;
}

// translate using multiple endpoints with timeout and retries
async function tryTranslate(text){
  const body = { q: text, source: 'kn', target: 'en', format:'text' };
  for (const ep of TRANSLATE_ENDPOINTS){
    log(`Trying translator: ${ep.name} (${ep.url})`);
    try {
      const res = await fetchWithTimeout(ep.url, {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
      }, 9000);
      if (!res.ok) {
        log(`${ep.name} returned HTTP ${res.status}`);
        continue;
      }
      const j = await res.json();
      // different endpoints return different fields:
      const translated = j.translatedText || j.translation || j.result || j[0] && j[0].map? j[0].map(x=>x[0]).join(''): null;
      if (translated && translated.trim().length){
        log(`Translation succeeded with ${ep.name}`);
        return { success:true, text:translated, source:ep.name, raw:j };
      } else {
        log(`${ep.name} returned empty translation`);
      }
    } catch(e){
      log(`${ep.name} failed: ${e.message}`);
    }
  }
  return { success:false };
}

function fetchWithTimeout(url, opts={}, ms=8000){
  return new Promise((resolve, reject) => {
    const timer = setTimeout(()=> reject(new Error('timeout')), ms);
    fetch(url, opts).then(res => { clearTimeout(timer); resolve(res); }).catch(err => { clearTimeout(timer); reject(err); });
  });
}

// main pipeline
async function pipeline(file){
  try {
    setProgress(2);
    log('Starting pipeline...');
    const best = await bestOcrFromFile(file);
    if (!best || !best.text) {
      ocrOut.textContent = '';
      translationOut.textContent = 'No OCR text found.';
      log('No OCR text found.');
      setProgress(0);
      return;
    }
    lastOcr = best.text;
    ocrOut.textContent = best.text;
    log(`Selected OCR variant: ${best.variant} (score ${best.score})`);

    // extract only Kannada lines/chunks for translation
    const kannadaChunks = (best.text.match(/[\u0C80-\u0CFF][^\n\r]*/g) || []).join('\n').trim();
    if (!kannadaChunks) {
      log('No Kannada detected in OCR text; nothing to translate.');
      translationOut.textContent = 'No Kannada detected to translate.';
      setProgress(100);
      return;
    }
    setProgress(70);
    log('Translating Kannada chunks...');
    const t = await tryTranslate(kannadaChunks);
    if (t.success) {
      translationOut.textContent = t.text;
      lastTranslation = t.text;
      setProgress(100);
    } else {
      translationOut.textContent = 'Translation failed (all endpoints failed).';
      setProgress(0);
    }

  } catch(e){
    log('Pipeline error: ' + (e && e.message ? e.message : e));
    setProgress(0);
  }
}

// file handling
fileEl.addEventListener('change', e => {
  const f = e.target.files[0];
  if (!f) return;
  lastFile = f;
  ocrOut.textContent = '';
  translationOut.textContent = '';
  pipeline(f);
});
runAgainBtn.addEventListener('click', ()=> { if (lastFile) pipeline(lastFile); else log('No last file'); });

// downloads and copy
downloadOcrFileBtn.addEventListener('click', ()=> {
  if (!lastOcr) return alert('No OCR text to download');
  downloadText('ocr-result.txt', lastOcr);
});
downloadTransFileBtn.addEventListener('click', ()=> {
  if (!lastTranslation) return alert('No translation to download');
  downloadText('translation.txt', lastTranslation);
});
copyOcrBtn.addEventListener('click', ()=> { if (!lastOcr) return alert('No OCR text'); navigator.clipboard.writeText(lastOcr).then(()=> alert('Copied OCR to clipboard')); });
downloadOcrBtn.addEventListener('click', ()=> { if (!lastOcr) return alert('No OCR text'); downloadText('ocr-result.txt', lastOcr); });

function downloadText(filename, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], { type:'text/plain' }));
  a.download = filename;
  a.click();
}

// show OCR variants (for debugging)
document.getElementById('showVariants').addEventListener('click', ()=> {
  alert('Variants debug: preview only. If you need, I can add separate canvases.');
});

log('Ready — upload an image with Kannada + English.');

/* expose for debug */
window._pipeline = pipeline;
</script>
</body>
</html>
