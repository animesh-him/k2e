<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robust Pipeline OCR (Kannada+English) → English Translation</title>

<!-- Tesseract.js v5 -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
  :root{
    --bg:#071021; --card:#0f1720; --muted:#9fb0c8; --accent1:#ff6b81; --accent2:#8a2be2; --text:#e6eef7;
  }
  body{ margin:0; font-family:Inter,Arial,Helvetica,sans-serif; background:linear-gradient(180deg,#03040a,#071021); color:var(--text); }
  .wrap{max-width:980px;margin:20px auto;padding:18px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  h1{margin:0;font-size:20px}
  .lead{color:var(--muted);font-size:13px;margin-top:6px}
  .grid{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
  .col{flex:1;min-width:280px}
  .card{padding:12px;border-radius:10px;background:var(--card);border:1px solid rgba(255,255,255,0.02)}
  input[type=file]{width:100%}
  .preview{width:100%;max-height:320px;object-fit:contain;border-radius:8px;background:#fff;margin-top:8px;display:none}
  .box{width:100%;min-height:140px;border-radius:8px;padding:10px;background:#071018;color:var(--text);font-family:monospace;white-space:pre-wrap;overflow:auto}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{padding:10px 12px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:white;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
  .small{font-size:13px;color:var(--muted)}
  .log{max-height:240px;overflow:auto;padding:10px;background:rgba(0,0,0,0.25);border-radius:8px;font-family:monospace;font-size:13px}
  .credits{font-family:Pacifico,cursive;text-align:right;margin-top:10px;color:rgba(255,255,255,0.9)}
  @media(max-width:820px){ .grid{flex-direction:column} .col{min-width:unset} }
</style>
</head>
<body>
  <div class="wrap">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h1>Pipeline OCR — Kannada + English → English Translation</h1>
        <div class="lead">High-accuracy mode: multiple preprocessing passes, rotations, chunked translation with fallbacks.</div>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="col card">
        <div class="small">Upload image (photo / screenshot). Processing starts automatically.</div>
        <input id="fileInput" type="file" accept="image/*" style="margin-top:8px"/>
        <div style="margin-top:10px" class="controls">
          <button id="processNow" class="secondary">Process Now</button>
          <button id="retryBtn" class="secondary">Retry last</button>
        </div>

        <img id="preview" class="preview" alt="preview"/>

        <div style="margin-top:10px" class="small">Pipeline Log</div>
        <div id="log" class="log">Idle. Upload an image to start.</div>
      </div>

      <div class="col card">
        <div class="small">OCR Combined Output (Kannada first + English)</div>
        <div id="ocrBox" class="box">(OCR will appear here)</div>
        <div class="controls">
          <button id="downloadOcr" class="secondary">Download OCR</button>
          <button id="copyOcr" class="secondary">Copy OCR</button>
        </div>

        <div style="margin-top:12px" class="small">English Translation (chunked & fallback)</div>
        <div id="transBox" class="box">(Translation will appear here)</div>
        <div class="controls" style="margin-top:8px">
          <button id="downloadTrans" class="secondary">Download Translation</button>
          <button id="retryTrans" class="secondary">Retry Translation</button>
        </div>

        <div class="credits">Created by Animesh</div>
      </div>
    </div>
  </div>

<script>
/* ================= CONFIG ================= */
const ROTATIONS = [-2,0,2];        // degrees to try for small skew
const MAX_DIM = 1600;              // max resize to speed up
const CHUNK_SIZE = 400;            // translation chunk size (safe <500)
const OCR_TIMEOUT = 25000;         // ms per recognition attempt
const TRANSLATION_TIMEOUT = 12000; // ms per translator request

const TRANSLATORS = [
  // MyMemory (GET) - sometimes gives decent results for short chunks
  { name:'MyMemory', type:'get', build: t => `https://api.mymemory.translated.net/get?q=${encodeURIComponent(t)}&langpair=kn|en` },
  // libretranslate.de (POST)
  { name:'libretranslate.de', type:'post', url:'https://libretranslate.de/translate' },
  // argosopentech
  { name:'argosopentech', type:'post', url:'https://translate.argosopentech.com/translate' },
  // astian (last fallback)
  { name:'astian', type:'post', url:'https://translate.astian.org/translate' }
];

/* ================= DOM ================= */
const fileInput = document.getElementById('fileInput');
const processNow = document.getElementById('processNow');
const retryBtn = document.getElementById('retryBtn');
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const ocrBox = document.getElementById('ocrBox');
const transBox = document.getElementById('transBox');
const downloadOcr = document.getElementById('downloadOcr');
const copyOcr = document.getElementById('copyOcr');
const downloadTrans = document.getElementById('downloadTrans');
const retryTrans = document.getElementById('retryTrans');

let lastFile = null;
let lastCombinedText = '';
let lastTranslation = '';

/* ================= Helpers ================= */
function log(msg){
  const ts = new Date().toLocaleTimeString();
  logEl.textContent = `${ts} — ${msg}\n` + logEl.textContent;
  console.log(msg);
}
function showOcr(t){ ocrBox.textContent = t || '(no OCR)'; }
function showTrans(t){ transBox.textContent = t || '(no translation)'; }
function downloadText(filename, text){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([text||''],{type:'text/plain'})); a.download=filename; a.click(); }
function copyText(t){ navigator.clipboard?.writeText(t).then(()=>alert('Copied'), ()=>alert('Copy failed')); }

/* ================= Preprocessing Utilities ================= */
function resizeCanvas(img, maxDim=MAX_DIM){
  const scale=Math.min(1, maxDim/Math.max(img.width,img.height));
  const c=document.createElement('canvas'); c.width=Math.round(img.width*scale); c.height=Math.round(img.height*scale);
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,c.width,c.height); return c;
}

function toGrayscale(c){
  const ctx=c.getContext('2d'); const id=ctx.getImageData(0,0,c.width,c.height), d=id.data;
  for(let i=0;i<d.length;i+=4){
    const v = Math.round(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(id,0,0);
  return c;
}

function contrastStretch(c){
  try {
    const ctx=c.getContext('2d'); const id=ctx.getImageData(0,0,c.width,c.height); const d=id.data;
    let min=255,max=0;
    for(let i=0;i<d.length;i+=4){ const lum=d[i]; if(lum<min)min=lum; if(lum>max)max=lum; }
    const range=Math.max(1,max-min);
    for(let i=0;i<d.length;i+=4){ const v=Math.round((d[i]-min)*255/range); d[i]=d[i+1]=d[i+2]=v; }
    ctx.putImageData(id,0,0);
  } catch(e){ log('contrast error: '+e.message); }
  return c;
}

function simpleBlur(c, radius=1){
  // approximate box blur by canvas filter if available
  try {
    const ctx=c.getContext('2d');
    if ('filter' in ctx){
      const tmp=document.createElement('canvas'); tmp.width=c.width; tmp.height=c.height;
      const tctx=tmp.getContext('2d'); tctx.filter=`blur(${radius}px)`; tctx.drawImage(c,0,0);
      return tmp;
    }
    return c;
  } catch(e){ return c; }
}

// Otsu threshold
function otsuThreshold(c){
  try {
    const ctx=c.getContext('2d'); const w=c.width,h=c.height; const id=ctx.getImageData(0,0,w,h); const d=id.data;
    const hist = new Array(256).fill(0);
    for(let i=0;i<d.length;i+=4) hist[d[i]]++;
    const total = w*h;
    let sum = 0;
    for(let t=0;t<256;t++) sum += t * hist[t];
    let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;
    for(let t=0;t<256;t++){
      wB += hist[t];
      if (wB === 0) continue;
      wF = total - wB;
      if (wF === 0) break;
      sumB += t * hist[t];
      const mB = sumB / wB;
      const mF = (sum - sumB) / wF;
      const varBetween = wB * wF * (mB - mF) * (mB - mF);
      if (varBetween > varMax) { varMax = varBetween; threshold = t; }
    }
    for(let i=0;i<d.length;i+=4){
      const v = d[i] > threshold ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){ log('otsu error: '+e.message); }
  return c;
}

// Morphological operations (binary canvas): erosion then dilation (open)
function morphologicalOpen(c, iterations=1){
  try {
    const w=c.width,h=c.height; const ctx=c.getContext('2d'); const id=ctx.getImageData(0,0,w,h); const d=id.data;
    const src = new Uint8ClampedArray(w*h);
    for(let i=0, j=0;i<d.length;i+=4,j++) src[j]=d[i] < 128 ? 0 : 1; // 1 = white
    // erosion
    for(let it=0; it<iterations; it++){
      const tmp = src.slice();
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let anyZero=false;
          for(let yy=-1;yy<=1;yy++){
            for(let xx=-1;xx<=1;xx++){
              if (src[(y+yy)*w + (x+xx)] === 0) { anyZero=true; break; }
            }
            if (anyZero) break;
          }
          tmp[y*w+x] = anyZero ? 0 : 1;
        }
      }
      src.set(tmp);
    }
    // dilation
    for(let it=0; it<iterations; it++){
      const tmp = src.slice();
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          if (src[y*w+x] === 1) {
            for(let yy=-1;yy<=1;yy++){
              for(let xx=-1;xx<=1;xx++){
                tmp[(y+yy)*w + (x+xx)] = 1;
              }
            }
          }
        }
      }
      src.set(tmp);
    }
    // write back
    for(let j=0,i=0;j<src.length;j++,i+=4){
      const v = src[j] ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
    ctx.putImageData(id,0,0);
  } catch(e){ log('morph error: '+e.message); }
  return c;
}

function rotateCanvas(src, deg){
  const r=deg*Math.PI/180; const w=src.width,h=src.height;
  const sin=Math.abs(Math.sin(r)), cos=Math.abs(Math.cos(r));
  const nw=Math.ceil(w*cos + h*sin), nh=Math.ceil(w*sin + h*cos);
  const c=document.createElement('canvas'); c.width=nw; c.height=nh;
  const ctx=c.getContext('2d'); ctx.fillStyle='white'; ctx.fillRect(0,0,nw,nh);
  ctx.translate(nw/2,nh/2); ctx.rotate(r); ctx.drawImage(src, -w/2, -h/2);
  return c;
}

function canvasToDataUrl(c){ return c.toDataURL('image/png'); }

/* ================= Safe recognize wrapper ================= */
function recognizeWithTimeout(dataUrl, lang, timeout=OCR_TIMEOUT){
  return new Promise(async (resolve, reject) => {
    let timed=false;
    const timer=setTimeout(()=>{ timed=true; reject(new Error('OCR timeout')); }, timeout);
    try {
      const res = await Tesseract.recognize(dataUrl, lang, { logger: m => { /*silent*/ } });
      if (!timed){ clearTimeout(timer); resolve(res.data); }
    } catch(err){
      if (!timed){ clearTimeout(timer); reject(err); }
    }
  });
}

/* ================= MAIN PIPELINE ================= */
fileInput.addEventListener('change', e => {
  const f = e.target.files && e.target.files[0];
  if (f){ lastFile = f; preview.src = URL.createObjectURL(f); preview.style.display='block'; runPipeline(f); }
});
processNow.addEventListener('click', ()=>{ if (fileInput.files[0]) runPipeline(fileInput.files[0]); else alert('Choose an image'); });
retryBtn.addEventListener('click', ()=>{ if (lastFile) runPipeline(lastFile); else alert('No last file'); });
retryTrans.addEventListener('click', ()=>{ if (lastCombinedText) doTranslationChunks(lastCombinedText); else alert('No OCR text'); });
downloadOcr.addEventListener('click', ()=> downloadText('ocr.txt', lastCombinedText));
copyOcr.addEventListener('click', ()=> copyText(lastCombinedText));
downloadTrans.addEventListener('click', ()=> downloadText('translation.txt', lastTranslation));

async function runPipeline(file){
  try {
    log('Starting pipeline for file: ' + file.name);
    showOcr('(processing...)'); showTrans('(waiting...)');
    const img = new Image(); img.src = URL.createObjectURL(file); await img.decode();

    const base = resizeCanvas(img, MAX_DIM);

    // build preprocessing variants
    const variants = [];
    // plain (grayscale + contrast)
    const plain = document.createElement('canvas'); plain.width=base.width; plain.height=base.height;
    plain.getContext('2d').drawImage(base,0,0);
    toGrayscale(plain); contrastStretch(plain);
    variants.push({name:'plain', canvas:plain});

    // contrast + sharpen (approx via blur and contrast)
    const cs = document.createElement('canvas'); cs.width=base.width; cs.height=base.height;
    cs.getContext('2d').drawImage(base,0,0);
    toGrayscale(cs); contrastStretch(cs);
    const csBlur = simpleBlur(cs,1);
    variants.push({name:'contrast_sharp', canvas:csBlur});

    // Otsu threshold + morphological open
    const sa = document.createElement('canvas'); sa.width=base.width; sa.height=base.height;
    sa.getContext('2d').drawImage(base,0,0);
    toGrayscale(sa); contrastStretch(sa); otsuThreshold(sa); morphologicalOpen(sa,1);
    variants.push({name:'otsu_open', canvas:sa});

    // Try Kannada OCR across variants and rotations
    let bestKan = {score:-1, text:'', details:null};
    let kanEarly = false;
    for (let vi=0; vi<variants.length && !kanEarly; vi++){
      const v = variants[vi];
      for (let ri=0; ri<ROTATIONS.length; ri++){
        const rot = ROTATIONS[ri];
        const canvas = (rot===0) ? v.canvas : rotateCanvas(v.canvas, rot);
        const url = canvasToDataUrl(canvas);
        log(`KAN try: variant=${v.name}, rot=${rot}°`);
        try {
          const data = await recognizeWithTimeout(url, 'kan');
          const text = (data && data.text) ? data.text.trim() : '';
          const kcount = (text.match(/[\u0C80-\u0CFF]/g) || []).length;
          const score = kcount*4 + text.replace(/\s+/g,'').length;
          log(`KAN result len=${text.length}, kannada=${kcount}, score=${score}`);
          if (score > bestKan.score){ bestKan = {score, text, details:{variant:v.name, rot}}; showOcr(bestKan.text); }
          // early accept heuristic: lots of Kannada characters
          if (kcount >= 80){ log('KAN early accept'); kanEarly = true; break; }
        } catch(err){
          log(`KAN failed variant=${v.name}, rot=${rot}: ${err.message}`);
        }
      }
    }

    // English OCR (use plain + small rotations)
    let bestEng = {score:-1, text:'', details:null};
    for (let ri=0; ri<ROTATIONS.length; ri++){
      const rot = ROTATIONS[ri];
      const canvas = (rot===0) ? plain : rotateCanvas(plain, rot);
      const url = canvasToDataUrl(canvas);
      log(`ENG try: rot=${rot}°`);
      try {
        const data = await recognizeWithTimeout(url, 'eng');
        const text = (data && data.text) ? data.text.trim() : '';
        const score = text.replace(/\s+/g,'').length;
        log(`ENG result len=${text.length}, score=${score}`);
        if (score > bestEng.score){ bestEng = {score, text, details:{rot}}; }
        if (score > 40) break;
      } catch(err){
        log(`ENG failed rot=${rot}: ${err.message}`);
      }
    }

    const kanText = bestKan.text || '';
    const engText = bestEng.text || '';
    const combined = ((kanText + "\n" + engText).trim()).replace(/\r/g,'');
    lastCombinedText = combined;
    showOcr(combined || '(no OCR result)');
    log(`Selected KAN variant=${bestKan.details?.variant||'n/a'} rot=${bestKan.details?.rot||0} score=${bestKan.score}`);
    log(`Selected ENG rot=${bestEng.details?.rot||0} score=${bestEng.score}`);

    const kcountTotal = (combined.match(/[\u0C80-\u0CFF]/g) || []).length;
    if (kcountTotal < 4 && combined.length < 10){
      log('No useful Kannada or English found. Try a better photo (closer, flatter, brighter).');
      showTrans('No translation: no useful OCR text.');
      return;
    }

    // proceed to translation (chunked)
    await doTranslationChunks(combined);

  } catch(err){
    log('Pipeline error: ' + (err && err.message || String(err)));
    showOcr('(pipeline error)');
    showTrans('(pipeline error)');
  }
}

/* ================= TRANSLATION: chunking & fallback ================= */
function chunkText(text, maxLen=CHUNK_SIZE){
  const paragraphs = text.split(/\n{2,}/g);
  const chunks = [];
  for (const p of paragraphs){
    if (!p.trim()) continue;
    let remaining = p.trim();
    while (remaining.length > 0){
      if (remaining.length <= maxLen){ chunks.push(remaining); break; }
      const sub = remaining.slice(0, maxLen);
      let splitPos = Math.max(sub.lastIndexOf('.'), sub.lastIndexOf('।'), sub.lastIndexOf('?'), sub.lastIndexOf('!'), sub.lastIndexOf('\n'));
      if (splitPos > Math.floor(maxLen*0.6)) {
        chunks.push(remaining.slice(0, splitPos+1).trim());
        remaining = remaining.slice(splitPos+1).trim();
      } else {
        const sp = sub.lastIndexOf(' ');
        const cut = (sp > 50) ? sp : maxLen;
        chunks.push(remaining.slice(0, cut).trim());
        remaining = remaining.slice(cut).trim();
      }
    }
  }
  if (chunks.length === 0 && text.trim()) chunks.push(text.trim().slice(0, maxLen));
  return chunks;
}

async function translateChunkWithEp(chunk, ep){
  try {
    if (ep.type === 'get'){
      const url = ep.build(chunk);
      const res = await fetchWithTimeout(url, {}, TRANSLATION_TIMEOUT);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const j = await res.json();
      const t = j.responseData && j.responseData.translatedText;
      if (t && t.trim()) return {ok:true, text:t, source:ep.name};
      return {ok:false};
    } else {
      const res = await fetchWithTimeout(ep.url, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ q: chunk, source:'kn', target:'en', format:'text' })
      }, TRANSLATION_TIMEOUT);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const j = await res.json();
      const t = j.translatedText || j.translation || j.result || (j[0] && j[0].map? j[0].map(x=>x[0]).join('') : null) || (j.data && j.data.translations && j.data.translations[0] && j.data.translations[0].translatedText);
      if (t && t.trim()) return {ok:true, text:t, source:ep.name};
      return {ok:false};
    }
  } catch(e){
    log(`${ep.name} failed: ${e.message}`);
    return {ok:false};
  }
}

async function doTranslationChunks(fullText){
  try {
    showTrans('Translating…'); log('Preparing chunks for translation...');
    const chunks = chunkText(fullText, CHUNK_SIZE);
    log(`Chunks: ${chunks.length}`);
    const results = [];
    for (let i=0;i<chunks.length;i++){
      const chunk = chunks[i];
      log(`Translating chunk ${i+1}/${chunks.length} (len=${chunk.length})`);
      let translated = null;
      // try each translator in order; stop when one returns text
      for (const ep of TRANSLATORS){
        const res = await translateChunkWithEp(chunk, ep);
        if (res.ok){ translated = res.text; log(`Chunk ${i+1} translated by ${res.source}`); break; }
      }
      if (!translated){
        translated = '[Translation unavailable for this chunk]';
        log(`Chunk ${i+1} failed on all endpoints.`);
      }
      results.push(translated);
      // small polite delay
      await new Promise(r=>setTimeout(r, 250));
    }
    const final = results.join('\n\n');
    lastTranslation = final;
    showTrans(final);
    log('Translation complete.');
  } catch(e){
    log('Translation pipeline error: '+(e && e.message));
    showTrans('Translation failed.');
  }
}

function fetchWithTimeout(url, opts={}, ms=8000){
  return new Promise((resolve,reject)=>{
    const timer=setTimeout(()=>reject(new Error('timeout')), ms);
    fetch(url, opts).then(res=>{ clearTimeout(timer); resolve(res); }).catch(err=>{ clearTimeout(timer); reject(err); });
  });
}

/* ================= initial log ================= */
log('Ready. Upload an image (Kannada + English). Processing starts automatically.');

</script>
</body>
</html>
