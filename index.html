<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Kannada OCR → Transliteration & Translation (Client)</title>

<!-- Tesseract.js (worker) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<!-- Aksharamukha for transliteration -->
<script src="https://unpkg.com/aksharamukha-js/dist/aksharamukha.min.js"></script>

<style>
  :root{
    --bg:#05060a; --card:rgba(255,255,255,0.02);
    --muted:#9fb0c8; --accent1:#ff6b81; --accent2:#8a2be2;
    --white:#e6eef7;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071021);color:var(--white);font-family:Inter,Arial,sans-serif}
  .wrap{max-width:980px;margin:14px auto;padding:12px;border-radius:12px;background:var(--card);border:1px solid rgba(255,255,255,0.03)}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:800}
  h1{margin:0;font-size:18px}
  p.lead{margin:0;color:var(--muted);font-size:13px}

  .main{display:flex;gap:16px;margin-top:14px;align-items:flex-start;flex-wrap:wrap}
  .left{flex:0 0 120px}
  .right{flex:1;min-width:260px}

  /* drop box ~1 inch */
  #drop{width:96px;height:96px;border-radius:10px;border:2px dashed rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;cursor:pointer;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
  .hint{font-size:12px;color:var(--muted);margin-top:8px;text-align:center}

  .card{padding:12px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
  .status{font-size:13px;color:var(--muted);line-height:1.4;white-space:pre-wrap}

  .canvasRow{display:flex;gap:12px;flex-wrap:wrap;margin-top:10px}
  .canvasBox{flex:1;min-width:240px}
  canvas{width:100%;height:auto;border-radius:8px;background:#fff;display:block}

  textarea{width:100%;min-height:120px;border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.04);background:rgba(0,0,0,0.4);color:var(--white);font-size:14px}

  .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .btn{padding:8px 12px;border-radius:8px;border:0;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:white;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .small{font-size:12px;color:var(--muted)}

  .credits{font-family:Pacifico,cursive;color:rgba(255,255,255,0.9);font-size:16px}
  .credits .sweep{position:relative;display:inline-block}
  .credits .sweep::after{content:'';position:absolute;left:-120%;top:0;bottom:0;width:120%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.18),transparent);transform:skewX(-10deg);animation:sweep 3.5s linear infinite}
  @keyframes sweep{0%{left:-120%}50%{left:120%}100%{left:120%}}

  /* responsive */
  @media (max-width:820px){
    .main{flex-direction:column}
    .left{order:2}
  }
  /* avoid canvas overflow */
  .canvasBox canvas{max-height:60vh}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo">KN→EN</div>
      <div>
        <h1>Kannada OCR → Transliteration & Translation</h1>
        <p class="lead">Automatic: upload image → OCR → transliterate → translate (optional). Status below.</p>
      </div>
    </div>

    <div>
      <select id="endpoint" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--white)">
        <option value="https://translate.argosopentech.com/translate">LibreTranslate (argos)</option>
        <option value="https://translate.astian.org/translate">LibreTranslate (astian)</option>
        <option value="none">No translation (only transliteration)</option>
      </select>
    </div>
  </header>

  <div class="main">
    <div class="left">
      <div class="card" style="text-align:center">
        <div id="drop" title="Click or drop image">Drop / Click</div>
        <div class="hint">1" × 1" uploader</div>
        <input id="file" type="file" accept="image/*" style="display:none">
        <div style="margin-top:10px" class="small">Processing starts automatically.</div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="small">Status log</div>
        <div id="log" class="status">Idle</div>
      </div>
    </div>

    <div class="right">
      <div class="card">
        <div class="row">
          <div class="small">Original / Preview</div>
          <div>
            <button id="dlOrig" class="btn secondary">Download</button>
          </div>
        </div>
        <div class="canvasRow" style="margin-top:10px">
          <div class="canvasBox"><canvas id="origCanvas"></canvas></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="row">
          <div class="small">Transliteration (Latin)</div>
          <div>
            <button id="dlTranslit" class="btn">Download</button>
          </div>
        </div>
        <textarea id="translitText" placeholder="Transliteration will appear here..." style="margin-top:10px;display:none"></textarea>
        <div class="canvasRow" style="margin-top:10px">
          <div class="canvasBox"><canvas id="translitCanvas" style="display:none"></canvas></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="row">
          <div class="small">Translation (English meaning)</div>
          <div>
            <button id="dlTrans" class="btn">Download</button>
          </div>
        </div>
        <textarea id="transText" placeholder="Translation will appear here..." style="margin-top:10px;display:none"></textarea>
        <div class="canvasRow" style="margin-top:10px">
          <div class="canvasBox"><canvas id="transCanvas" style="display:none"></canvas></div>
        </div>
      </div>

      <div style="margin-top:12px;display:flex;justify-content:flex-end">
        <div class="credits"><span class="sweep">Created by Animesh</span></div>
      </div>
    </div>
  </div>
</div>

<script>
/* Full pipeline client-side:
 - preprocess image -> dataURL
 - Tesseract worker recognize with 'kan+eng'
 - Check if extracted text is meaningful
 - transliterate using Aksharamukha (Kannada->ISO)
 - optional translate per-line via selected endpoint
 - draw transliteration & translation on canvases (replace boxes)
 - only show outputs if OCR produced useful text
 - logs shown in #log
*/

/* DOM */
const drop = document.getElementById('drop');
const fileInput = document.getElementById('file');
const logEl = document.getElementById('log');
const endpointSel = document.getElementById('endpoint');

const origCanvas = document.getElementById('origCanvas');
const translitCanvas = document.getElementById('translitCanvas');
const transCanvas = document.getElementById('transCanvas');

const translitTextArea = document.getElementById('translitText');
const transTextArea = document.getElementById('transText');

const dlOrig = document.getElementById('dlOrig');
const dlTranslit = document.getElementById('dlTranslit');
const dlTrans = document.getElementById('dlTrans');

let latestImage = null;
let lastOCRText = '';

/* helpers */
function log(msg){ logEl.textContent = msg; console.log(msg); }
function showError(msg){ log('ERROR: ' + msg); console.error(msg); }

/* drag & click wiring */
drop.addEventListener('click', ()=> fileInput.click());
['dragenter','dragover'].forEach(e => drop.addEventListener(e, ev=>{ ev.preventDefault(); drop.style.borderColor='rgba(255,107,129,0.6)'; }));
['dragleave','drop'].forEach(e => drop.addEventListener(e, ev=>{ ev.preventDefault(); drop.style.borderColor='rgba(255,255,255,0.06)'; }));
drop.addEventListener('drop', ev=>{ ev.preventDefault(); const f = ev.dataTransfer.files && ev.dataTransfer.files[0]; if (f) startPipeline(f); });
fileInput.addEventListener('change', ev=>{ const f = ev.target.files && ev.target.files[0]; if (f) startPipeline(f); fileInput.value=''; });

/* downloads */
dlOrig.addEventListener('click', ()=> downloadCanvas(origCanvas,'original.png'));
dlTranslit.addEventListener('click', ()=> downloadCanvas(translitCanvas,'transliteration.png'));
dlTrans.addEventListener('click', ()=> downloadCanvas(transCanvas,'translation.png'));
function downloadCanvas(c, name){ if(!c) return; const link=document.createElement('a'); link.href=c.toDataURL('image/png'); link.download=name; link.click(); }

/* preprocess: resize + grayscale + contrast stretch */
function preprocessImage(img, maxW=1200){
  const canvas = document.createElement('canvas');
  const scale = Math.min(1, maxW / img.width);
  canvas.width = Math.round(img.width * scale);
  canvas.height = Math.round(img.height * scale);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  // basic contrast stretch
  const imd = ctx.getImageData(0,0,canvas.width,canvas.height);
  const d = imd.data;
  // compute luminance min/max for stretch
  let min=255, max=0;
  for (let i=0;i<d.length;i+=4){
    const lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    if (lum < min) min = lum;
    if (lum > max) max = lum;
  }
  const range = Math.max(1, max-min);
  for (let i=0;i<d.length;i+=4){
    let lum = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    let v = Math.round((lum - min) * 255 / range);
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(imd,0,0);
  return canvas.toDataURL('image/png');
}

/* draw base image to canvases */
function drawBaseOnCanvases(dataUrl){
  const img = new Image();
  img.src = dataUrl;
  return new Promise((res, rej)=>{
    img.onload = ()=>{
      [origCanvas, translitCanvas, transCanvas].forEach(c=>{
        c.width = img.width;
        c.height = img.height;
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,c.width,c.height);
        ctx.drawImage(img,0,0);
      });
      latestImage = img;
      res(img);
    };
    img.onerror = (e)=> rej(e);
  });
}

/* compare text usefulness: returns true if OCR produced meaningful text */
function ocrIsUseful(text){
  if (!text) return false;
  const cleaned = text.replace(/\s+/g,'').replace(/[0-9\W_]+/g,'');
  return cleaned.length >= 5; // at least 5 non-punct characters
}

/* create worker and run OCR */
async function runOCR(dataUrl){
  setStatus('Loading OCR worker...');
  const worker = Tesseract.createWorker({
    logger: m => {
      if (m.status) setStatus(`OCR: ${m.status} ${m.progress?Math.round(m.progress*100)+'%':''}`);
    }
  });
  await worker.load();
  await worker.loadLanguage('kan+eng');
  await worker.initialize('kan+eng');
  setStatus('Recognizing...');
  const result = await worker.recognize(dataUrl, { tessedit_pageseg_mode: Tesseract.PSM.AUTO });
  await worker.terminate();
  return result.data || {};
}

/* transform OCR results into line objects with bbox */
function buildLinesFromOCR(data){
  const lines = (data.lines || []).map(ln=>{
    const b = ln.bbox || ln.boundingBox || { x0:ln.x0||0, y0:ln.y0||0, x1:ln.x1||0, y1:ln.y1||0 };
    return { text: (ln.text||'').trim(), bbox: { x: b.x0, y: b.y0, w: (b.x1 - b.x0), h: (b.y1 - b.y0) } };
  });
  // fallback: if no lines, group words
  if (!lines.length && data.words && data.words.length){
    // group words roughly by y coordinate
    const groups = {};
    data.words.forEach(w=>{
      const wb = w.bbox || { x0:w.x0||0, y0:w.y0||0, x1:(w.x0||0)+(w.width||0), y1:(w.y0||0)+(w.height||0) };
      const key = Math.round((wb.y0||0)/20);
      groups[key] = groups[key] || [];
      groups[key].push({ text: w.text, bbox: { x: wb.x0, y: wb.y0, w: wb.x1 - wb.x0, h: wb.y1 - wb.y0 } });
    });
    const out = [];
    Object.keys(groups).sort((a,b)=>a-b).forEach(k=>{
      const arr = groups[k];
      const text = arr.map(a=>a.text).join(' ');
      const x = Math.min(...arr.map(a=>a.bbox.x));
      const y = Math.min(...arr.map(a=>a.bbox.y));
      const r = Math.max(...arr.map(a=>a.bbox.x + a.bbox.w));
      const btm = Math.max(...arr.map(a=>a.bbox.y + a.bbox.h));
      out.push({ text, bbox:{ x, y, w: r-x, h: btm - y } });
    });
    return out;
  }
  return lines;
}

/* transliterate lines using Aksharamukha */
function transliterateLines(lines){
  return lines.map(l=>{
    let out = '';
    try { out = Aksharamukha.convert('Kannada','ISO', l.text || ''); }
    catch(e){ out = l.text || ''; }
    return { ...l, out };
  });
}

/* translate per-line using endpoint */
async function translateLines(lines, endpoint){
  const out = [];
  for (let i=0;i<lines.length;i++){
    const src = lines[i].text || lines[i].out || '';
    if (!src.trim()){
      out.push({ ...lines[i], out: '' });
      continue;
    }
    try {
      const resp = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ q: src, source: 'kn', target: 'en', format: 'text' })
      });
      const j = await resp.json();
      out.push({ ...lines[i], out: j.translatedText || (j.translation || src) });
    } catch(e){
      out.push({ ...lines[i], out: src });
    }
    // be gentle for public endpoints
    await new Promise(r=>setTimeout(r, 150));
    setStatus(`Translating per-line... (${i+1}/${lines.length})`);
  }
  return out;
}

/* draw overlay: erase box and write out text centered with wrapping */
function drawOverlayOnCanvas(canvas, lines){
  const ctx = canvas.getContext('2d');
  // assume image already drawn
  ctx.save();
  ctx.textBaseline = 'top';
  lines.forEach(l=>{
    const x = Math.max(0, l.bbox.x | 0), y = Math.max(0, l.bbox.y | 0);
    const w = Math.max(30, l.bbox.w | 0), h = Math.max(18, l.bbox.h | 0);
    // erase
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    ctx.fillRect(x-2, y-2, w+4, h+6);
    // text
    const text = (l.out || '').trim();
    if (!text) return;
    // font size
    let fontSize = Math.max(12, Math.min(Math.floor(h * 0.75), 28));
    ctx.font = `${fontSize}px Inter, Arial`;
    ctx.fillStyle = '#111';
    // wrap
    const padding = 6;
    const wrapped = wrapText(ctx, text, Math.max(10, w - padding*2));
    const totalHeight = wrapped.length * fontSize * 1.05;
    let startY = y + Math.max(0, (h - totalHeight)/2);
    if (startY < y) startY = y + 1;
    wrapped.forEach((ln, idx)=>{
      const tw = ctx.measureText(ln).width;
      const tx = x + Math.max(0, (w - tw)/2);
      ctx.fillText(ln, tx, startY + idx * fontSize * 1.05);
    });
  });
  ctx.restore();
}

/* simple canvas text wrapper */
function wrapText(ctx, text, maxWidth){
  if (!text) return [''];
  const words = text.split(/\s+/);
  const lines = [];
  let cur = '';
  for (let i=0;i<words.length;i++){
    const test = cur ? (cur + ' ' + words[i]) : words[i];
    if (ctx.measureText(test).width > maxWidth && cur){
      lines.push(cur);
      cur = words[i];
    } else cur = test;
  }
  if (cur) lines.push(cur);
  return lines;
}

/* status helper */
function setStatus(s){ log(s); }

/* main pipeline */
async function startPipeline(file){
  try {
    setStatus('1) Loading image...');
    const img = new Image();
    img.src = URL.createObjectURL(file);
    await img.decode();

    setStatus('2) Preprocessing image for better OCR...');
    const preDataUrl = preprocessImage(img, 1200);

    setStatus('3) Drawing base image on canvases...');
    await drawBaseOnCanvases(preDataUrl);

    setStatus('4) Running OCR (kan+eng)...');
    const ocrData = await runOCR(preDataUrl);

    const fullText = (ocrData && (ocrData.text || ocrData.words && (ocrData.words.map(w=>w.text).join(' ') ) )) || '';
    lastOCRText = fullText || '';
    if (!ocrIsUseful(fullText)) {
      setStatus('OCR produced no useful text. Stopping. (No outputs shown)');
      // hide output areas
      translitTextArea.style.display = 'none';
      translitCanvas.style.display = 'none';
      transTextArea.style.display = 'none';
      transCanvas.style.display = 'none';
      return;
    }
    setStatus('OCR succeeded — extracted text length: ' + fullText.trim().length);

    setStatus('5) Building line segments...');
    const lines = buildLinesFromOCR(ocrData);
    if (!lines.length) {
      setStatus('No lines found — showing raw OCR text');
      translitTextArea.style.display = 'block';
      translitTextArea.value = fullText;
    }

    setStatus('6) Transliteration (client)...');
    const translitLines = transliterateLines(lines);
    // show transliteration text (concatenate lines)
    translitTextArea.style.display = 'block';
    translitTextArea.value = translitLines.map(l=>l.out).join('\n');

    // draw transliteration overlay
    translitCanvas.style.display = 'block';
    drawOverlayOnCanvas(translitCanvas, translitLines);

    // translate if endpoint selected
    const endpoint = endpointSel.value;
    if (endpoint && endpoint !== 'none') {
      setStatus('7) Translating per-line via endpoint: ' + endpoint);
      const translated = await translateLines(translitLines, endpoint);
      transTextArea.style.display = 'block';
      transTextArea.value = translated.map(l=>l.out).join('\n');
      transCanvas.style.display = 'block';
      drawOverlayOnCanvas(transCanvas, translated);
      setStatus('8) Done. Outputs available.');
    } else {
      setStatus('7) No translation endpoint selected — only transliteration produced.');
      transTextArea.style.display = 'none';
      transCanvas.style.display = 'none';
    }

  } catch (err){
    showError(err && err.message ? err.message : String(err));
  }
}

/* kick off from file */
function handleFilePicker(file){
  if (!file) return;
  startPipeline(file);
}

/* wire in */
fileInput.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if (f) handleFilePicker(f);
  fileInput.value = '';
});

/* allow drag/drop click already wired above */

/* Expose globals for console debugging */
window._ocrDebug = { startPipeline, drawBaseOnCanvases, runOCR };

/* initial status */
setStatus('Idle — drop or click to upload an image.');

</script>
</body>
</html>
